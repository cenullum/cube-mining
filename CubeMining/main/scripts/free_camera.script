go.property("sensitivity", 0.002)
go.property("speed", 200)

function init(self)
    msg.post(".", "acquire_input_focus")
    self.pitch = 0
    self.yaw = 0

    self.move_input = vmath.vector3()
    self.vertical_input = 0
    self.sprinting = false

    -- Initial Lock
    self.mouse_locked = true
    window.set_mouse_lock(self.mouse_locked)
end

function update(self, dt)
    local rot = go.get_rotation()
    local p = go.get_position()

    local forward = vmath.rotate(rot, vmath.vector3(0, 0, -1))
    local right = vmath.rotate(rot, vmath.vector3(1, 0, 0))
    local up = vmath.vector3(0, 1, 0)

    local move_speed = self.speed
    if self.sprinting then move_speed = move_speed * 3 end

    local move_dir = vmath.vector3()

    if self.move_input.z < 0 then move_dir = move_dir + forward end
    if self.move_input.z > 0 then move_dir = move_dir - forward end
    if self.move_input.x < 0 then move_dir = move_dir - right end
    if self.move_input.x > 0 then move_dir = move_dir + right end

    move_dir = move_dir + up * self.vertical_input

    if vmath.length_sqr(move_dir) > 0.0001 then
        move_dir = vmath.normalize(move_dir)
    end

    if self.mouse_locked then
        go.set_position(p + move_dir * move_speed * dt)
    end

    -- View Matrix
    local view = vmath.matrix4_from_quat(rot)
    view = vmath.inv(view)
    local pos_inv = vmath.matrix4_translation(-go.get_position())
    view = view * pos_inv

    -- Projection Matrix
    local width, height = window.get_size()
    local aspect = width / height
    local fov = math.rad(45) -- 45 degrees vertical FOV is standard
    local near = 0.1
    local far = 10000.0
    local projection = vmath.matrix4_perspective(fov, aspect, near, far)

    msg.post("@render:", "set_view_projection", { id = hash("camera"), view = view, projection = projection })
end

function on_input(self, action_id, action)
    if not action_id then
        if self.mouse_locked then
            self.yaw = self.yaw - action.dx * self.sensitivity
            self.pitch = self.pitch + action.dy * self.sensitivity

            if self.pitch > 1.5 then self.pitch = 1.5 end
            if self.pitch < -1.5 then self.pitch = -1.5 end

            local q = vmath.quat_rotation_y(self.yaw) * vmath.quat_rotation_x(self.pitch)
            go.set_rotation(q)
        end
        return
    end

    if action_id == hash("key_esc") and action.released then
        self.mouse_locked = false
        window.set_mouse_lock(false)
    elseif action_id == hash("click") and action.pressed and not self.mouse_locked then
        self.mouse_locked = true
        window.set_mouse_lock(true)
    end

    if action_id == hash("move_forward") then
        self.move_input.z = action.pressed and -1 or (action.released and 0 or self.move_input.z)
    elseif action_id == hash("move_backward") then
        self.move_input.z = action.pressed and 1 or (action.released and 0 or self.move_input.z)
    elseif action_id == hash("move_left") then
        self.move_input.x = action.pressed and -1 or (action.released and 0 or self.move_input.x)
    elseif action_id == hash("move_right") then
        self.move_input.x = action.pressed and 1 or (action.released and 0 or self.move_input.x)
    elseif action_id == hash("move_up") then
        self.vertical_input = action.pressed and 1 or (action.released and 0 or self.vertical_input)
    elseif action_id == hash("move_down") then
        self.vertical_input = action.pressed and -1 or (action.released and 0 or self.vertical_input)
    elseif action_id == hash("sprint") then
        self.sprinting = not action.released
    end
end
