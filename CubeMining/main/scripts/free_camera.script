go.property("sensitivity", 0.002)
go.property("speed", 5)

function init(self)
    msg.post(".", "acquire_input_focus")
    self.pitch = 0
    self.yaw = 0

    self.inputs = {
        forward = 0,
        backward = 0,
        left = 0,
        right = 0,
        up = 0,
        down = 0
    }
    self.sprinting = false

    -- Initial Lock
    window.set_mouse_lock(true)

    self.performance_mode = 0
end

function update(self, dt)
    local rot = go.get_rotation()
    local p = go.get_position()

    local forward = vmath.rotate(rot, vmath.vector3(0, 0, -1))
    local right = vmath.rotate(rot, vmath.vector3(1, 0, 0))
    local up = vmath.vector3(0, 1, 0)

    local move_speed = self.speed
    if self.sprinting then move_speed = move_speed * 3 end

    local move_dir = forward * (self.inputs.forward - self.inputs.backward)
    move_dir = move_dir + right * (self.inputs.right - self.inputs.left)
    move_dir = move_dir + up * (self.inputs.up - self.inputs.down)

    if vmath.length_sqr(move_dir) > 0.0001 then
        move_dir = vmath.normalize(move_dir)
    end

    if window.get_mouse_lock() then
        go.set_position(p + move_dir * move_speed * dt)
    end

    -- View Matrix
    local view = vmath.matrix4_from_quat(rot)
    view = vmath.inv(view)
    local pos_inv = vmath.matrix4_translation(-go.get_position())
    view = view * pos_inv

    -- Projection Matrix
    local width, height = window.get_size()
    local aspect = width / height
    local fov = math.rad(45) -- 45 degrees vertical FOV is standard
    local near = 0.1
    local far = 10000.0
    local projection = vmath.matrix4_perspective(fov, aspect, near, far)

    msg.post("@render:", "set_view_projection", { id = hash("camera"), view = view, projection = projection })

    -- Optimized: Push current data at the end of update to avoid 1-frame lag
    if self.performance_mode > 0 then
        _G.cam_pos = go.get_position()
        _G.cam_rot = go.get_rotation()
    end
end

function on_input(self, action_id, action)
    if not action_id then
        if window.get_mouse_lock() then
            self.yaw = self.yaw - action.dx * self.sensitivity
            self.pitch = self.pitch + action.dy * self.sensitivity

            if self.pitch > 1.5 then self.pitch = 1.5 end
            if self.pitch < -1.5 then self.pitch = -1.5 end

            local q = vmath.quat_rotation_y(self.yaw) * vmath.quat_rotation_x(self.pitch)
            go.set_rotation(q)
        end
        return
    end

    if action_id == hash("key_esc") and action.released then
        window.set_mouse_lock(false)
    elseif (action_id == hash("click") or action_id == hash("click_right")) and action.pressed and not window.get_mouse_lock() then
        window.set_mouse_lock(true)
    end

    if action_id == hash("move_forward") then
        self.inputs.forward = action.pressed and 1 or (action.released and 0 or self.inputs.forward)
    elseif action_id == hash("move_backward") then
        self.inputs.backward = action.pressed and 1 or (action.released and 0 or self.inputs.backward)
    elseif action_id == hash("move_left") then
        self.inputs.left = action.pressed and 1 or (action.released and 0 or self.inputs.left)
    elseif action_id == hash("move_right") then
        self.inputs.right = action.pressed and 1 or (action.released and 0 or self.inputs.right)
    elseif action_id == hash("move_up") then
        self.inputs.up = action.pressed and 1 or (action.released and 0 or self.inputs.up)
    elseif action_id == hash("move_down") then
        self.inputs.down = action.pressed and 1 or (action.released and 0 or self.inputs.down)
    elseif action_id == hash("sprint") then
        self.sprinting = not action.released
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("set_performance_mode") then
        self.performance_mode = message.mode
        if self.performance_mode == 0 then
            _G.cam_pos = nil
            _G.cam_rot = nil
        end
    end
end
