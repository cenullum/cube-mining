-- generate_voxel.script
-- This script manages dynamic voxel mesh generation using a greedy meshing algorithm.
-- It handles world state, optimizes rendering by merging faces, and updates the GPU buffer at runtime.

local block_data = require "main.scripts.block_data"

local vmath = vmath
local resource = resource
local buffer = buffer
local go = go
local msg = msg
local factory = factory
local hash = hash

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("grid_size", 16)

local H_MESH = hash("mesh")
local PATCH_BUFFER = "/assets/models/patch_%s.bufferc"

_G.stats_faces = 0
_G.stats_vertices = 0
_G.stats_mesh_build_time = 0

local function create_mesh(self)
    local object = {}
    object.go_id = factory.create(self.mesh_prefab)
    object.mesh_url = msg.url(object.go_id)
    object.mesh_url.fragment = H_MESH
    return object
end

local function get_block(self, x, y, z)
    local size = self.grid_size or 0
    if x < 0 or x >= size or y < 0 or y >= size or z < 0 or z >= size then
        return 0 -- Air out of bounds
    end
    return self.world[x][y][z]
end

local function update_mesh(self)
    local start_time = os.clock()
    local grid_size = self.grid_size
    local world = self.world
    local mask = self.mask
    local positions = self.positions
    local texcoord0 = self.texcoord0
    local texcoord1 = self.texcoord1

    local get_block_local = get_block
    local greedy_faces = 0
    local quad_idx = 0

    local function add_quad(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z, uv_data, w, h)
        local base = quad_idx * 18
        local uv_base = quad_idx * 12
        local offset_base = quad_idx * 24

        local uw, uh = uv_data.w, uv_data.h
        local wuh, huh = w * uw, h * uh

        -- V1
        positions[base + 1] = p1x; positions[base + 2] = p1y; positions[base + 3] = p1z
        texcoord0[uv_base + 1] = 0; texcoord0[uv_base + 2] = huh
        -- V2
        positions[base + 4] = p2x; positions[base + 5] = p2y; positions[base + 6] = p2z
        texcoord0[uv_base + 3] = wuh; texcoord0[uv_base + 4] = huh
        -- V3
        positions[base + 7] = p3x; positions[base + 8] = p3y; positions[base + 9] = p3z
        texcoord0[uv_base + 5] = wuh; texcoord0[uv_base + 6] = 0
        -- V4 (Same as V1)
        positions[base + 10] = p1x; positions[base + 11] = p1y; positions[base + 12] = p1z
        texcoord0[uv_base + 7] = 0; texcoord0[uv_base + 8] = huh
        -- V5 (Same as V3)
        positions[base + 13] = p3x; positions[base + 14] = p3y; positions[base + 15] = p3z
        texcoord0[uv_base + 9] = wuh; texcoord0[uv_base + 10] = 0
        -- V6
        positions[base + 16] = p4x; positions[base + 17] = p4y; positions[base + 18] = p4z
        texcoord0[uv_base + 11] = 0; texcoord0[uv_base + 12] = 0

        local uu, uv = uv_data.u, uv_data.v
        for i = 0, 5 do
            local off = offset_base + i * 4 + 1
            texcoord1[off] = uu
            texcoord1[off + 1] = uv
            texcoord1[off + 2] = uw
            texcoord1[off + 3] = uh
        end
        quad_idx = quad_idx + 1
    end

    for d = 1, 6 do
        for i = 0, grid_size - 1 do
            for m = 1, grid_size * grid_size do mask[m] = false end

            -- Visibility Scan
            for j = 0, grid_size - 1 do
                for k = 0, grid_size - 1 do
                    local x, y, z, nx, ny, nz
                    if d == 1 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z + 1
                    elseif d == 2 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z - 1
                    elseif d == 3 then
                        x, y, z = k, i, j; nx, ny, nz = x, y + 1, z
                    elseif d == 4 then
                        x, y, z = k, i, j; nx, ny, nz = x, y - 1, z
                    elseif d == 5 then
                        x, y, z = i, k, j; nx, ny, nz = x + 1, y, z
                    elseif d == 6 then
                        x, y, z = i, k, j; nx, ny, nz = x - 1, y, z
                    end

                    local b_id = world[x][y][z]
                    local neighbor_id = get_block_local(self, nx, ny, nz)
                    local b_def = block_data.get_block(b_id)
                    local n_def = block_data.get_block(neighbor_id)

                    if b_def and not b_def.transparent then
                        if not n_def or n_def.transparent then
                            mask[j * grid_size + k + 1] = b_id
                        end
                    end
                end
            end

            -- Greedy Merge
            for j = 0, grid_size - 1 do
                local row_offset = j * grid_size
                for k = 0, grid_size - 1 do
                    local b_id = mask[row_offset + k + 1]
                    if b_id then
                        local w, h = 1, 1
                        while k + w < grid_size and mask[row_offset + k + w + 1] == b_id do w = w + 1 end
                        local can_expand_h = true
                        while j + h < grid_size do
                            local next_row_offset = (j + h) * grid_size
                            for r = 0, w - 1 do
                                if mask[next_row_offset + k + r + 1] ~= b_id then
                                    can_expand_h = false; break
                                end
                            end
                            if not can_expand_h then break end
                            h = h + 1
                        end

                        local b_def = block_data.get_block(b_id)
                        local uv_data = b_def and b_def.uvs and b_def.uvs[d]
                        if uv_data then
                            if d == 1 then
                                add_quad(k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j + h -
                                    0.5, i + 0.5, k - 0.5, j + h - 0.5, i + 0.5, uv_data, w, h)
                            elseif d == 2 then
                                add_quad(k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5, j + h - 0.5,
                                    i - 0.5, k + w - 0.5, j + h - 0.5, i - 0.5, uv_data, w, h)
                            elseif d == 3 then
                                add_quad(k - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5,
                                    i + 0.5, j - 0.5, k - 0.5, i + 0.5, j - 0.5, uv_data, w, h)
                            elseif d == 4 then
                                add_quad(k - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5,
                                    j + h - 0.5, k - 0.5, i - 0.5, j + h - 0.5, uv_data, w, h)
                            elseif d == 5 then
                                add_quad(i + 0.5, k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5,
                                    j + h - 0.5, i + 0.5, k - 0.5, j + h - 0.5, uv_data, w, h)
                            elseif d == 6 then
                                add_quad(i - 0.5, k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5,
                                    j + h - 0.5, i - 0.5, k + w - 0.5, j + h - 0.5, uv_data, w, h)
                            end
                            greedy_faces = greedy_faces + 1
                        end

                        for r = 0, h - 1 do
                            local proc_row_offset = (j + r) * grid_size
                            for c = 0, w - 1 do mask[proc_row_offset + k + c + 1] = false end
                        end
                    end
                end
            end
        end
    end

    local current_vertex_count = quad_idx * 18
    local prev_vertex_count = self.prev_vertex_count or 0
    if prev_vertex_count > current_vertex_count then
        for i = current_vertex_count + 1, prev_vertex_count do positions[i] = 0 end
    end
    self.prev_vertex_count = current_vertex_count

    _G.stats_faces = greedy_faces
    _G.stats_vertices = quad_idx * 4
    resource.set_buffer(self.buffer_resource, self.buf)
    go.set(self.mesh_url, "vertices", self.buffer_resource)
    _G.stats_mesh_build_time = (os.clock() - start_time) * 1000
end

local function create_chunk(self, world_data)
    local mesh_go = create_mesh(self)
    local grid_size = self.grid_size
    _G.grid_size = grid_size
    local num_cubes = grid_size * grid_size * grid_size

    local atlas = resource.get_atlas(self.game_atlas)
    go.set(mesh_go.mesh_url, "texture0", hash(atlas.texture))

    block_data.init(self.game_atlas)

    self.mask = {}
    for i = 1, grid_size * grid_size do self.mask[i] = false end

    local max_faces = num_cubes * 3
    local buf = buffer.create(max_faces * 6, {
        { name = hash("position"),  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = hash("texcoord0"), type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = hash("texcoord1"), type = buffer.VALUE_TYPE_FLOAT32, count = 4 }
    })

    self.buf = buf
    self.positions = buffer.get_stream(buf, "position")
    self.texcoord0 = buffer.get_stream(buf, "texcoord0")
    self.texcoord1 = buffer.get_stream(buf, "texcoord1")

    self.world = world_data
    self.total_cubes = 0
    _G.shared_cubemap = {}
    for cx = 0, grid_size - 1 do
        for cy = 0, grid_size - 1 do
            for cz = 0, grid_size - 1 do
                if self.world[cx][cy][cz] ~= 0 then
                    self.total_cubes = self.total_cubes + 1
                    local cube_idx = cx + cy * grid_size + cz * grid_size * grid_size
                    _G.shared_cubemap[cube_idx] = true
                end
            end
        end
    end

    self.mesh_url = mesh_go.mesh_url
    self.buffer_resource = resource.create_buffer(string.format(PATCH_BUFFER, 7), { buffer = buf })

    update_mesh(self)

    local offset = -self.grid_size / 2 + 0.5
    go.set_position(vmath.vector3(offset, offset, 490), mesh_go.go_id)
end

function init(self)
    local grid_size = self.grid_size
    local world_data = {}
    math.randomseed(os.time())

    for cx = 0, grid_size - 1 do
        world_data[cx] = {}
        for cy = 0, grid_size - 1 do
            world_data[cx][cy] = {}
            for cz = 0, grid_size - 1 do
                if cy == 0 then
                    world_data[cx][cy][cz] = 2 -- Unbreakable layer
                else
                    if math.random() < 0.3 then
                        world_data[cx][cy][cz] = 3 -- Golden Ore
                    else
                        world_data[cx][cy][cz] = 1 -- Stone
                    end
                end
            end
        end
    end

    create_chunk(self, world_data)
    self.time = 0
end

function on_message(self, message_id, message, sender)
    if message_id == hash("destroy_cube") then
        local gx, gy, gz = message.gx, message.gy, message.gz
        if gx and gy and gz and self.grid_size then
            if self.world[gx] and self.world[gx][gy] and self.world[gx][gy][gz] then
                local b_id = self.world[gx][gy][gz]
                if b_id ~= 0 and b_id ~= 2 then -- Not air and not unbreakable
                    self.world[gx][gy][gz] = 0
                    self.total_cubes = (self.total_cubes or 1) - 1
                    local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                    update_mesh(self)
                end
            end
        end
    elseif message_id == hash("place_cube") then
        local gx, gy, gz = message.gx, message.gy, message.gz
        if gx and gy and gz and self.grid_size then
            if gx >= 0 and gx < self.grid_size and gy >= 0 and gy < self.grid_size and gz >= 0 and gz < self.grid_size then
                if self.world[gx] and self.world[gx][gy] and self.world[gx][gy][gz] == 0 then
                    self.world[gx][gy][gz] = 1
                    self.total_cubes = (self.total_cubes or 0) + 1
                    local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                    update_mesh(self)
                end
            end
        end
    end
end

function final(self)
    resource.release(string.format(PATCH_BUFFER, 7))
end
