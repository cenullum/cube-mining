-- generate_voxel.script
-- This script manages dynamic voxel mesh generation using a greedy meshing algorithm.
-- It handles world state, optimizes rendering by merging faces, and updates the GPU buffer at runtime.

local block_data = require "main.scripts.block_data"
local world = require "main.scripts.world"

local vmath = vmath
local resource = resource
local buffer = buffer
local go = go
local msg = msg
local factory = factory
local hash = hash

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("grid_size", 16)

local H_MESH = hash("mesh")
local H_POSITION = hash("position")
local H_TEXCOORD0 = hash("texcoord0")
local H_TEXCOORD1 = hash("texcoord1")
local H_COLOR = hash("color") -- New stream for AO
local H_DESTROY_CUBE = hash("destroy_cube")
local H_PLACE_CUBE = hash("place_cube")
local H_TEXTURE0 = hash("texture0")
local H_VERTICES = hash("vertices")
local H_TOGGLE_AO = hash("toggle_ao")

local PATCH_BUFFER = "/assets/models/patch_%s.bufferc"

_G.stats_faces = 0
_G.stats_vertices = 0
_G.stats_mesh_build_time = 0

local function create_mesh(self)
    local object = {}
    object.go_id = factory.create(self.mesh_prefab)
    object.mesh_url = msg.url(object.go_id)
    object.mesh_url.fragment = H_MESH
    return object
end

local function get_block(self, x, y, z)
    local size = self.grid_size or 0
    if x < 0 or x >= size or y < 0 or y >= size or z < 0 or z >= size then
        return 0 -- Air out of bounds
    end
    -- Use global world data
    return world.get_block(x, y, z)
end

-- Helper to check if a block is opaque (occluding)
local function is_opaque(self, x, y, z, cache)
    -- Cache key: Simple string or hashed integer.
    -- X, Y, Z can be negative or > grid_size (neighbors), so handle that.
    -- Using string key for reliability with negative coords.
    local key = x .. "_" .. y .. "_" .. z
    if cache and cache[key] ~= nil then
        return cache[key]
    end

    local b_id = get_block(self, x, y, z)
    local result = false
    if b_id ~= 0 then
        local def = block_data.get_block(b_id)
        result = def and not def.transparent
    end

    if cache then cache[key] = result end
    return result
end

-- Calculate Ambient Occlusion for a specific vertex of a face
-- Returns a value 0 (bright) to 3 (dark)
local function vertex_ao(side1, side2, corner)
    if side1 and side2 then return 3 end
    return (side1 and 1 or 0) + (side2 and 1 or 0) + (corner and 1 or 0)
end

-- Calculates AO for the 4 corners of a greedy-meshable unit quad (1x1 face)
-- Returns table {ao_p1, ao_p2, ao_p3, ao_p4}
-- Mapping corresponds to P1, P2, P3, P4 in add_quad
local function calculate_ao(self, x, y, z, face_dir, cache)
    if not self.ao_enabled then return { 0, 0, 0, 0 } end

    local vals = {}
    local function op(tx, ty, tz) return is_opaque(self, tx, ty, tz, cache) end

    -- NOTE: P1..P4 defs must match add_quad logic
    -- Check add_quad logic for each D to confirm P1..P4 positions

    if face_dir == 1 then -- Front (Z+)
        -- P1: Min X, Min Y
        -- P2: Max X, Min Y
        -- P3: Max X, Max Y
        -- P4: Min X, Max Y
        local zc = z + 1
        vals[1] = vertex_ao(op(x - 1, y, zc), op(x, y - 1, zc), op(x - 1, y - 1, zc))
        vals[2] = vertex_ao(op(x + 1, y, zc), op(x, y - 1, zc), op(x + 1, y - 1, zc))
        vals[3] = vertex_ao(op(x + 1, y, zc), op(x, y + 1, zc), op(x + 1, y + 1, zc))
        vals[4] = vertex_ao(op(x - 1, y, zc), op(x, y + 1, zc), op(x - 1, y + 1, zc))
    elseif face_dir == 2 then -- Back (Z-)
        -- P1: Max X, Min Y
        -- P2: Min X, Min Y
        -- P3: Min X, Max Y
        -- P4: Max X, Max Y
        local zc = z - 1
        vals[1] = vertex_ao(op(x + 1, y, zc), op(x, y - 1, zc), op(x + 1, y - 1, zc))
        vals[2] = vertex_ao(op(x - 1, y, zc), op(x, y - 1, zc), op(x - 1, y - 1, zc))
        vals[3] = vertex_ao(op(x - 1, y, zc), op(x, y + 1, zc), op(x - 1, y + 1, zc))
        vals[4] = vertex_ao(op(x + 1, y, zc), op(x, y + 1, zc), op(x + 1, y + 1, zc))
    elseif face_dir == 3 then -- Top (Y+)
        -- P1: Min X, Max Z
        -- P2: Max X, Max Z
        -- P3: Max X, Min Z
        -- P4: Min X, Min Z
        local yc = y + 1
        vals[1] = vertex_ao(op(x - 1, yc, z), op(x, yc, z + 1), op(x - 1, yc, z + 1))
        vals[2] = vertex_ao(op(x + 1, yc, z), op(x, yc, z + 1), op(x + 1, yc, z + 1))
        vals[3] = vertex_ao(op(x + 1, yc, z), op(x, yc, z - 1), op(x + 1, yc, z - 1))
        vals[4] = vertex_ao(op(x - 1, yc, z), op(x, yc, z - 1), op(x - 1, yc, z - 1))
    elseif face_dir == 4 then -- Bottom (Y-)
        -- P1: Min X, Min Z
        -- P2: Max X, Min Z
        -- P3: Max X, Max Z
        -- P4: Min X, Max Z
        local yc = y - 1
        vals[1] = vertex_ao(op(x - 1, yc, z), op(x, yc, z - 1), op(x - 1, yc, z - 1))
        vals[2] = vertex_ao(op(x + 1, yc, z), op(x, yc, z - 1), op(x + 1, yc, z - 1))
        vals[3] = vertex_ao(op(x + 1, yc, z), op(x, yc, z + 1), op(x + 1, yc, z + 1))
        vals[4] = vertex_ao(op(x - 1, yc, z), op(x, yc, z + 1), op(x - 1, yc, z + 1))
    elseif face_dir == 5 then -- Right (X+)
        -- Mapping: x=i, y=k, z=j.
        -- P1: Min Y, Min Z (y-0.5, z-0.5)
        -- P2: Max Y, Min Z (y+w-0.5, z-0.5)
        -- P3: Max Y, Max Z (y+w-0.5, z+h-0.5)
        -- P4: Min Y, Max Z (y-0.5, z+h-0.5)
        local xc = x + 1
        vals[1] = vertex_ao(op(xc, y - 1, z), op(xc, y, z - 1), op(xc, y - 1, z - 1))
        vals[2] = vertex_ao(op(xc, y + 1, z), op(xc, y, z - 1), op(xc, y + 1, z - 1))
        vals[3] = vertex_ao(op(xc, y + 1, z), op(xc, y, z + 1), op(xc, y + 1, z + 1))
        vals[4] = vertex_ao(op(xc, y - 1, z), op(xc, y, z + 1), op(xc, y - 1, z + 1))
    elseif face_dir == 6 then -- Left (X-)
        -- Mapping: x=i, y=k, z=j
        -- P1: Max Y, Min Z
        -- P2: Min Y, Min Z
        -- P3: Min Y, Max Z
        -- P4: Max Y, Max Z
        local xc = x - 1
        vals[1] = vertex_ao(op(xc, y + 1, z), op(xc, y, z - 1), op(xc, y + 1, z - 1))
        vals[2] = vertex_ao(op(xc, y - 1, z), op(xc, y, z - 1), op(xc, y - 1, z - 1))
        vals[3] = vertex_ao(op(xc, y - 1, z), op(xc, y, z + 1), op(xc, y - 1, z + 1))
        vals[4] = vertex_ao(op(xc, y + 1, z), op(xc, y, z + 1), op(xc, y + 1, z + 1))
    end

    return vals
end

local H_NORMAL = hash("normal")

-- Visibility scan and greedy merge...
local function update_mesh(self)
    local start_time = os.clock()
    local grid_size = self.grid_size
    -- Use global world data
    local mask = self.mask
    local positions = self.positions
    local texcoord0 = self.texcoord0
    local texcoord1 = self.texcoord1
    local colors = self.colors
    local normals = self.normals

    local get_block_local = get_block
    local greedy_faces = 0
    local quad_idx = 0

    -- Opacity Cache for this frame
    local opaque_cache = {}

    local function add_quad(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z, uv_data, w, h, nx, ny, nz,
                            ao_vals)
        local base = quad_idx * 18
        local uv_base = quad_idx * 12
        local offset_base = quad_idx * 24

        -- Convert AO (0-3) to float (1.0 - 0.25)
        -- 0 -> 1.0 (Bright)
        -- 3 -> 0.4 (Dark)
        local function ao_f(val) return 1.0 - (val * 0.2) end

        -- Map vals to P1..P4
        local ao1 = ao_f(ao_vals[1])
        local ao2 = ao_f(ao_vals[2])
        local ao3 = ao_f(ao_vals[3])
        local ao4 = ao_f(ao_vals[4])

        local uw, uh = uv_data.w, uv_data.h
        local wuh, huh = w * uw, h * uh

        -- V1 (P1)
        positions[base + 1] = p1x; positions[base + 2] = p1y; positions[base + 3] = p1z
        texcoord0[uv_base + 1] = 0; texcoord0[uv_base + 2] = huh
        colors[offset_base + 1] = ao1; colors[offset_base + 2] = ao1; colors[offset_base + 3] = ao1; colors[offset_base + 4] = 1

        -- V2 (P2)
        positions[base + 4] = p2x; positions[base + 5] = p2y; positions[base + 6] = p2z
        texcoord0[uv_base + 3] = wuh; texcoord0[uv_base + 4] = huh
        colors[offset_base + 5] = ao2; colors[offset_base + 6] = ao2; colors[offset_base + 7] = ao2; colors[offset_base + 8] = 1

        -- V3 (P3)
        positions[base + 7] = p3x; positions[base + 8] = p3y; positions[base + 9] = p3z
        texcoord0[uv_base + 5] = wuh; texcoord0[uv_base + 6] = 0
        colors[offset_base + 9] = ao3; colors[offset_base + 10] = ao3; colors[offset_base + 11] = ao3; colors[offset_base + 12] = 1

        -- V4 (Same as V1/P1)
        positions[base + 10] = p1x; positions[base + 11] = p1y; positions[base + 12] = p1z
        texcoord0[uv_base + 7] = 0; texcoord0[uv_base + 8] = huh
        colors[offset_base + 13] = ao1; colors[offset_base + 14] = ao1; colors[offset_base + 15] = ao1; colors[offset_base + 16] = 1

        -- V5 (Same as V3/P3)
        positions[base + 13] = p3x; positions[base + 14] = p3y; positions[base + 15] = p3z
        texcoord0[uv_base + 9] = wuh; texcoord0[uv_base + 10] = 0
        colors[offset_base + 17] = ao3; colors[offset_base + 18] = ao3; colors[offset_base + 19] = ao3; colors[offset_base + 20] = 1

        -- V6 (P4)
        positions[base + 16] = p4x; positions[base + 17] = p4y; positions[base + 18] = p4z
        texcoord0[uv_base + 11] = 0; texcoord0[uv_base + 12] = 0
        colors[offset_base + 21] = ao4; colors[offset_base + 22] = ao4; colors[offset_base + 23] = ao4; colors[offset_base + 24] = 1

        -- Normals
        for i = 0, 5 do
            normals[base + i * 3 + 1] = nx
            normals[base + i * 3 + 2] = ny
            normals[base + i * 3 + 3] = nz
        end

        local uu, uv = uv_data.u, uv_data.v
        for i = 0, 5 do
            local off = offset_base + i * 4 + 1
            texcoord1[off] = uu
            texcoord1[off + 1] = uv
            texcoord1[off + 2] = uw
            texcoord1[off + 3] = uh
        end
        quad_idx = quad_idx + 1
    end

    for d = 1, 6 do
        for i = 0, grid_size - 1 do
            for m = 1, grid_size * grid_size do mask[m] = nil end

            -- Visibility Scan
            for j = 0, grid_size - 1 do
                for k = 0, grid_size - 1 do
                    local x, y, z, nx, ny, nz
                    if d == 1 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z + 1
                    elseif d == 2 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z - 1
                    elseif d == 3 then
                        x, y, z = k, i, j; nx, ny, nz = x, y + 1, z
                    elseif d == 4 then
                        x, y, z = k, i, j; nx, ny, nz = x, y - 1, z
                    elseif d == 5 then
                        x, y, z = i, k, j; nx, ny, nz = x + 1, y, z
                    elseif d == 6 then
                        x, y, z = i, k, j; nx, ny, nz = x - 1, y, z
                    end

                    local b_id = world.get_block(x, y, z)
                    local neighbor_id = get_block_local(self, nx, ny, nz)
                    local b_def = block_data.get_block(b_id)
                    local n_def = block_data.get_block(neighbor_id)

                    if b_def and not b_def.transparent then
                        if not n_def or n_def.transparent then
                            local ao_vals = calculate_ao(self, x, y, z, d, opaque_cache)
                            local a0, a1, a2, a3 = ao_vals[1], ao_vals[2], ao_vals[3], ao_vals[4]

                            -- Encode AO into mask.
                            local ao_hash = a0 + a1 * 4 + a2 * 16 + a3 * 64
                            mask[j * grid_size + k + 1] = b_id + ao_hash * 100000
                        end
                    end
                end
            end

            -- Greedy Merge
            for j = 0, grid_size - 1 do
                local row_offset = j * grid_size
                for k = 0, grid_size - 1 do
                    local val = mask[row_offset + k + 1]
                    if val then
                        local b_id = val % 100000
                        local ao_hash = math.floor(val / 100000)
                        local a0 = ao_hash % 4
                        local a1 = math.floor(ao_hash / 4) % 4
                        local a2 = math.floor(ao_hash / 16) % 4
                        local a3 = math.floor(ao_hash / 64)

                        local w, h = 1, 1
                        while k + w < grid_size and mask[row_offset + k + w + 1] == val do w = w + 1 end
                        local can_expand_h = true
                        while j + h < grid_size do
                            local next_row_offset = (j + h) * grid_size
                            for r = 0, w - 1 do
                                if mask[next_row_offset + k + r + 1] ~= val then
                                    can_expand_h = false; break
                                end
                            end
                            if not can_expand_h then break end
                            h = h + 1
                        end

                        local ao_vals = { a0, a1, a2, a3 }
                        local b_def = block_data.get_block(b_id)
                        local uv_data = b_def and b_def.uvs and b_def.uvs[d]
                        if uv_data then
                            if d == 1 then
                                -- P1, P2, P3, P4 matches calc_aoD1
                                add_quad(k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j + h -
                                    0.5, i + 0.5, k - 0.5, j + h - 0.5, i + 0.5, uv_data, w, h, 0, 0, 1, ao_vals)
                            elseif d == 2 then
                                add_quad(k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5, j + h - 0.5,
                                    i - 0.5, k + w - 0.5, j + h - 0.5, i - 0.5, uv_data, w, h, 0, 0, -1, ao_vals)
                            elseif d == 3 then
                                add_quad(k - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5,
                                    i + 0.5, j - 0.5, k - 0.5, i + 0.5, j - 0.5, uv_data, w, h, 0, 1, 0, ao_vals)
                            elseif d == 4 then
                                add_quad(k - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5,
                                    j + h - 0.5, k - 0.5, i - 0.5, j + h - 0.5, uv_data, w, h, 0, -1, 0, ao_vals)
                            elseif d == 5 then
                                add_quad(i + 0.5, k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5,
                                    j + h - 0.5, i + 0.5, k - 0.5, j + h - 0.5, uv_data, w, h, 1, 0, 0, ao_vals)
                            elseif d == 6 then
                                add_quad(i - 0.5, k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5,
                                    j + h - 0.5, i - 0.5, k + w - 0.5, j + h - 0.5, uv_data, w, h, -1, 0, 0, ao_vals)
                            end
                            greedy_faces = greedy_faces + 1
                        end

                        for r = 0, h - 1 do
                            local proc_row_offset = (j + r) * grid_size
                            for c = 0, w - 1 do mask[proc_row_offset + k + c + 1] = nil end
                        end
                    end
                end
            end
        end
    end

    local current_vertex_count = quad_idx * 18
    local prev_vertex_count = self.prev_vertex_count or 0
    if prev_vertex_count > current_vertex_count then
        for i = current_vertex_count + 1, prev_vertex_count do positions[i] = 0 end
    end
    self.prev_vertex_count = current_vertex_count
    _G.stats_faces = greedy_faces
    _G.stats_vertices = quad_idx * 4
    resource.set_buffer(self.buffer_resource, self.buf)
    go.set(self.mesh_url, H_VERTICES, self.buffer_resource)
    _G.stats_mesh_build_time = (os.clock() - start_time) * 1000
end

local function create_chunk(self)
    local mesh_go = create_mesh(self)
    local grid_size = self.grid_size
    _G.grid_size = grid_size
    local num_cubes = grid_size * grid_size * grid_size

    local atlas = resource.get_atlas(self.game_atlas)
    go.set(mesh_go.mesh_url, H_TEXTURE0, hash(atlas.texture))

    block_data.init(self.game_atlas)

    self.mask = {}
    for i = 1, grid_size * grid_size do self.mask[i] = false end

    local max_faces   = num_cubes * 3
    local buf         = buffer.create(max_faces * 6, {
        { name = H_POSITION,  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = H_TEXCOORD0, type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = H_TEXCOORD1, type = buffer.VALUE_TYPE_FLOAT32, count = 4 },
        { name = H_NORMAL,    type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = H_COLOR,     type = buffer.VALUE_TYPE_FLOAT32, count = 4 }
    })

    self.buf          = buf
    self.positions    = buffer.get_stream(buf, H_POSITION)
    self.texcoord0    = buffer.get_stream(buf, H_TEXCOORD0)
    self.texcoord1    = buffer.get_stream(buf, H_TEXCOORD1)
    self.normals      = buffer.get_stream(buf, H_NORMAL)
    self.colors       = buffer.get_stream(buf, H_COLOR)

    -- Removed self.world assignment, accessing world.data directly or via get_block
    self.total_cubes  = 0
    _G.shared_cubemap = {}
    for cx = 0, grid_size - 1 do
        for cy = 0, grid_size - 1 do
            for cz = 0, grid_size - 1 do
                if world.get_block(cx, cy, cz) ~= 0 then
                    self.total_cubes = self.total_cubes + 1
                    local cube_idx = cx + cy * grid_size + cz * grid_size * grid_size
                    _G.shared_cubemap[cube_idx] = true
                end
            end
        end
    end

    self.mesh_url = mesh_go.mesh_url
    self.buffer_resource = resource.create_buffer(string.format(PATCH_BUFFER, 7), { buffer = buf })

    update_mesh(self)

    local offset = -self.grid_size / 2 + 0.5
    go.set_position(vmath.vector3(offset, offset, 490), mesh_go.go_id)
end

function init(self)
    local grid_size = self.grid_size

    self.ao_enabled = true -- Default On

    -- Initialize global world
    world.init(grid_size)

    math.randomseed(os.time())

    for cx = 0, grid_size - 1 do
        for cy = 0, grid_size - 1 do
            for cz = 0, grid_size - 1 do
                local block_id = 0
                if cy == 0 then
                    block_id = 2 -- Unbreakable layer
                else
                    if math.random() < 0.3 then
                        block_id = 3 -- Golden Ore
                    else
                        block_id = 1 -- Stone
                    end
                end
                world.set_block(cx, cy, cz, block_id)
            end
        end
    end

    create_chunk(self) -- Removed world_data argument
    self.time = 0

    -- Listen for AO toggle
    msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message, sender)
    if message_id == H_DESTROY_CUBE then
        local gx, gy, gz = message.gx, message.gy, message.gz
        if gx and gy and gz and self.grid_size then
            local b_id = world.get_block(gx, gy, gz)
            if b_id ~= 0 and b_id ~= 2 then -- Not air and not unbreakable
                world.set_block(gx, gy, gz, 0)
                self.total_cubes = (self.total_cubes or 1) - 1
                local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                update_mesh(self)
            end
        end
    elseif message_id == H_PLACE_CUBE then
        local gx, gy, gz = message.gx, message.gy, message.gz
        if gx and gy and gz and self.grid_size then
            if gx >= 0 and gx < self.grid_size and gy >= 0 and gy < self.grid_size and gz >= 0 and gz < self.grid_size then
                if world.get_block(gx, gy, gz) == 0 then
                    world.set_block(gx, gy, gz, 1)
                    self.total_cubes = (self.total_cubes or 0) + 1
                    local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                    update_mesh(self)
                end
            end
        end
    elseif message_id == hash("set_blocks_area") then
        local center_gx, center_gy, center_gz = message.gx, message.gy, message.gz
        local radius = message.radius or 1
        local target_id = message.block_id or 0
        local modified = false

        if center_gx and center_gy and center_gz and self.grid_size then
            for gx = center_gx - radius, center_gx + radius do
                for gy = center_gy - radius, center_gy + radius do
                    for gz = center_gz - radius, center_gz + radius do
                        -- Bound checking within grid and above unbreakable layer
                        if gx >= 0 and gx < self.grid_size and
                            gy > 0 and gy < self.grid_size and
                            gz >= 0 and gz < self.grid_size then
                            local current_id = world.get_block(gx, gy, gz)
                            if current_id ~= target_id and current_id ~= 2 then -- Don't break unbreakable (2)
                                world.set_block(gx, gy, gz, target_id)

                                local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                                if target_id == 0 then
                                    if current_id ~= 0 then self.total_cubes = (self.total_cubes or 1) - 1 end
                                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                                else
                                    if current_id == 0 then self.total_cubes = (self.total_cubes or 0) + 1 end
                                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                                end
                                modified = true
                            end
                        end
                    end
                end
            end
            if modified then update_mesh(self) end
        end
    elseif message_id == hash("set_blocks_list") then
        local blocks = message.blocks
        local modified = false
        if blocks and self.grid_size then
            for _, b in ipairs(blocks) do
                local gx, gy, gz, target_id = b.gx, b.gy, b.gz, b.id or 0
                if gx and gy and gz then
                    if gx >= 0 and gx < self.grid_size and
                        gy > 0 and gy < self.grid_size and
                        gz >= 0 and gz < self.grid_size then
                        local current_id = world.get_block(gx, gy, gz)
                        if current_id ~= target_id and current_id ~= 2 then
                            world.set_block(gx, gy, gz, target_id)

                            local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                            if target_id == 0 then
                                if current_id ~= 0 then self.total_cubes = (self.total_cubes or 1) - 1 end
                                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                            else
                                if current_id == 0 then self.total_cubes = (self.total_cubes or 0) + 1 end
                                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                            end
                            modified = true
                        end
                    end
                end
            end
            if modified then update_mesh(self) end
        end
    elseif message_id == H_TOGGLE_AO or message_id == hash("toggle_ao") then
        self.ao_enabled = not self.ao_enabled
        update_mesh(self)
        print("AO Enabled: " .. tostring(self.ao_enabled))
    end
end

function final(self)
    resource.release(string.format(PATCH_BUFFER, 7))
end
