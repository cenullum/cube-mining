-- generate_voxel.script
-- This script manages dynamic voxel mesh generation using a greedy meshing algorithm.
-- It handles world state, optimizes rendering by merging faces, and updates the GPU buffer at runtime.

local block_data = require "main.scripts.block_data"
local world = require "main.scripts.world"
local sm = require "main.scripts.sound_manager"

local vmath = vmath
local resource = resource
local buffer = buffer
local go = go
local msg = msg
local factory = factory
local hash = hash

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("grid_size", 16)
go.property("torch_factory", msg.url())
go.property("breaking_texture", resource.texture("/assets/images/effects/breaking.png"))

local TEMP_POS = vmath.vector3()

local H_MESH = hash("mesh")
local H_POSITION = hash("position")
local H_TEXCOORD0 = hash("texcoord0")
local H_TEXCOORD1 = hash("texcoord1")
local H_COLOR = hash("color") -- New stream for AO
local H_DESTROY_CUBE = hash("destroy_cube")
local H_PLACE_CUBE = hash("place_cube")
local H_TEXTURE0 = hash("texture0")
local H_VERTICES = hash("vertices")
local H_TOGGLE_AO = hash("toggle_ao")
local H_TOGGLE_LIGHT_MODE = hash("toggle_light_mode")

local PATCH_BUFFER = "/assets/models/patch_%s.bufferc"

_G.stats_faces = 0
_G.stats_vertices = 0
_G.stats_mesh_build_time = 0

local function create_mesh(self)
    local object = {}
    object.go_id = factory.create(self.mesh_prefab)
    object.mesh_url = msg.url(object.go_id)
    object.mesh_url.fragment = H_MESH
    return object
end

local function get_block(self, x, y, z)
    local size = self.grid_size or 0
    if x < 0 or x >= size or y < 0 or y >= size or z < 0 or z >= size then
        return 0 -- Air out of bounds
    end
    -- Use global world data
    return world.get_block(x, y, z)
end

-- Helper to check if a block is opaque (occluding)
local function is_opaque(self, x, y, z, cache)
    -- Cache key: Simple string or hashed integer.
    -- X, Y, Z can be negative or > grid_size (neighbors), so handle that.
    -- Using string key for reliability with negative coords.
    local key = x .. "_" .. y .. "_" .. z
    if cache and cache[key] ~= nil then
        return cache[key]
    end

    local b_id = get_block(self, x, y, z)
    local result = false
    if b_id ~= 0 then
        local def = block_data.get_block(b_id)
        result = def and not def.transparent
    end

    if cache then cache[key] = result end
    return result
end

-- Calculate Ambient Occlusion for a specific vertex of a face
-- Returns a value 0 (bright) to 3 (dark)
local function vertex_ao(side1, side2, corner)
    if side1 and side2 then return 3 end
    return (side1 and 1 or 0) + (side2 and 1 or 0) + (corner and 1 or 0)
end

-- Calculates AO for the 4 corners of a greedy-meshable unit quad (1x1 face)
-- Returns table {ao_p1, ao_p2, ao_p3, ao_p4}
-- Mapping corresponds to P1, P2, P3, P4 in add_quad
local function calculate_ao(self, x, y, z, face_dir, cache)
    if not self.ao_enabled then return { 0, 0, 0, 0 } end

    local vals = {}
    local function op(tx, ty, tz) return is_opaque(self, tx, ty, tz, cache) end

    -- NOTE: P1..P4 defs must match add_quad logic
    -- Check add_quad logic for each D to confirm P1..P4 positions

    if face_dir == 1 then -- Front (Z+)
        -- P1: Min X, Min Y
        -- P2: Max X, Min Y
        -- P3: Max X, Max Y
        -- P4: Min X, Max Y
        local zc = z + 1
        vals[1] = vertex_ao(op(x - 1, y, zc), op(x, y - 1, zc), op(x - 1, y - 1, zc))
        vals[2] = vertex_ao(op(x + 1, y, zc), op(x, y - 1, zc), op(x + 1, y - 1, zc))
        vals[3] = vertex_ao(op(x + 1, y, zc), op(x, y + 1, zc), op(x + 1, y + 1, zc))
        vals[4] = vertex_ao(op(x - 1, y, zc), op(x, y + 1, zc), op(x - 1, y + 1, zc))
    elseif face_dir == 2 then -- Back (Z-)
        -- P1: Max X, Min Y
        -- P2: Min X, Min Y
        -- P3: Min X, Max Y
        -- P4: Max X, Max Y
        local zc = z - 1
        vals[1] = vertex_ao(op(x + 1, y, zc), op(x, y - 1, zc), op(x + 1, y - 1, zc))
        vals[2] = vertex_ao(op(x - 1, y, zc), op(x, y - 1, zc), op(x - 1, y - 1, zc))
        vals[3] = vertex_ao(op(x - 1, y, zc), op(x, y + 1, zc), op(x - 1, y + 1, zc))
        vals[4] = vertex_ao(op(x + 1, y, zc), op(x, y + 1, zc), op(x + 1, y + 1, zc))
    elseif face_dir == 3 then -- Top (Y+)
        -- P1: Min X, Max Z
        -- P2: Max X, Max Z
        -- P3: Max X, Min Z
        -- P4: Min X, Min Z
        local yc = y + 1
        vals[1] = vertex_ao(op(x - 1, yc, z), op(x, yc, z + 1), op(x - 1, yc, z + 1))
        vals[2] = vertex_ao(op(x + 1, yc, z), op(x, yc, z + 1), op(x + 1, yc, z + 1))
        vals[3] = vertex_ao(op(x + 1, yc, z), op(x, yc, z - 1), op(x + 1, yc, z - 1))
        vals[4] = vertex_ao(op(x - 1, yc, z), op(x, yc, z - 1), op(x - 1, yc, z - 1))
    elseif face_dir == 4 then -- Bottom (Y-)
        -- P1: Min X, Min Z
        -- P2: Max X, Min Z
        -- P3: Max X, Max Z
        -- P4: Min X, Max Z
        local yc = y - 1
        vals[1] = vertex_ao(op(x - 1, yc, z), op(x, yc, z - 1), op(x - 1, yc, z - 1))
        vals[2] = vertex_ao(op(x + 1, yc, z), op(x, yc, z - 1), op(x + 1, yc, z - 1))
        vals[3] = vertex_ao(op(x + 1, yc, z), op(x, yc, z + 1), op(x + 1, yc, z + 1))
        vals[4] = vertex_ao(op(x - 1, yc, z), op(x, yc, z + 1), op(x - 1, yc, z + 1))
    elseif face_dir == 5 then -- Right (X+)
        -- Mapping: x=i, y=k, z=j.
        -- P1: Min Y, Min Z (y-0.5, z-0.5)
        -- P2: Max Y, Min Z (y+w-0.5, z-0.5)
        -- P3: Max Y, Max Z (y+w-0.5, z+h-0.5)
        -- P4: Min Y, Max Z (y-0.5, z+h-0.5)
        local xc = x + 1
        vals[1] = vertex_ao(op(xc, y - 1, z), op(xc, y, z - 1), op(xc, y - 1, z - 1))
        vals[2] = vertex_ao(op(xc, y + 1, z), op(xc, y, z - 1), op(xc, y + 1, z - 1))
        vals[3] = vertex_ao(op(xc, y + 1, z), op(xc, y, z + 1), op(xc, y + 1, z + 1))
        vals[4] = vertex_ao(op(xc, y - 1, z), op(xc, y, z + 1), op(xc, y - 1, z + 1))
    elseif face_dir == 6 then -- Left (X-)
        -- Mapping: x=i, y=k, z=j
        -- P1: Max Y, Min Z
        -- P2: Min Y, Min Z
        -- P3: Min Y, Max Z
        -- P4: Max Y, Max Z
        local xc = x - 1
        vals[1] = vertex_ao(op(xc, y + 1, z), op(xc, y, z - 1), op(xc, y + 1, z - 1))
        vals[2] = vertex_ao(op(xc, y - 1, z), op(xc, y, z - 1), op(xc, y - 1, z - 1))
        vals[3] = vertex_ao(op(xc, y - 1, z), op(xc, y, z + 1), op(xc, y - 1, z + 1))
        vals[4] = vertex_ao(op(xc, y + 1, z), op(xc, y, z + 1), op(xc, y + 1, z + 1))
    end

    return vals
end

local function calculate_light_smooth(self, face_dir, p1_x, p1_y, p1_z, p2_x, p2_y, p2_z, p3_x, p3_y, p3_z, p4_x, p4_y,
                                      p4_z, channel)
    local vals = { 0, 0, 0, 0 }

    local function get_l(tx, ty, tz)
        local l = world.get_light(tx, ty, tz, channel)
        if channel == 1 and not l then return 15 end
        if channel == 0 and not l then return 0 end
        return l
    end

    local function avg_light(x, y, z, dx1, dy1, dz1, dx2, dy2, dz2, dx3, dy3, dz3)
        -- To smooth light at a vertex, we average the light value of the 4 blocks sharing that vertex that are outside the solid mesh
        -- Since this is blocky, we simply average the lights
        local l1 = get_l(x, y, z)
        local l2 = get_l(x + dx1, y + dy1, z + dz1)
        local l3 = get_l(x + dx2, y + dy2, z + dz2)
        local l4 = get_l(x + dx3, y + dy3, z + dz3)
        return (l1 + l2 + l3 + l4) / 4.0
    end

    -- We pass the normal of the block face (nx, ny, nz) to know which adjacent blocks to average
    -- For greedy meshing, P1..P4 are corners. Since greedy meshing can make large faces, smooth lighting
    -- at the vertices of a large face will NOT BE PERFECT unless we partition it, but we can do a simple average at the 4 extrema points.

    -- NOTE: Due to greedy meshing creating arbitrary sized quads, true per-vertex smooth lighting
    -- requires writing a custom chunk mesher that interpolates over the whole face, OR
    -- we disable greedy meshing when smooth lighting is on.
    -- For now, we take the light of the block directly above the face.

    return {
        get_l(p1_x, p1_y, p1_z),
        get_l(p2_x, p2_y, p2_z),
        get_l(p3_x, p3_y, p3_z),
        get_l(p4_x, p4_y, p4_z)
    }
end

local H_NORMAL = hash("normal")

-- Visibility scan and greedy merge...
local function update_mesh(self)
    local start_time = os.clock()
    local grid_size = self.grid_size
    -- Use global world data
    local mask = self.mask
    local positions = self.positions
    local texcoord0 = self.texcoord0
    local texcoord1 = self.texcoord1
    local colors = self.colors
    local normals = self.normals

    local get_block_local = get_block
    local greedy_faces = 0
    local quad_idx = 0

    local offset = -self.grid_size / 2 + 0.5
    local mesh_edges = {}

    -- Opacity Cache for this frame
    local opaque_cache = {}

    local function add_quad(p1x, p1y, p1z, p2x, p2y, p2z, p3x, p3y, p3z, p4x, p4y, p4z, uv_data, w, h, nx, ny, nz,
                            ao_vals, light_vals, face_dir)
        local base = quad_idx * 18
        local uv_base = quad_idx * 12
        local offset_base = quad_idx * 24

        -- Convert AO (0-3) to float (1.0 - 0.25)
        -- 0 -> 1.0 (Bright)
        -- 3 -> 0.4 (Dark)
        local function ao_f(val) return 1.0 - (val * 0.2) end

        -- Map vals to P1..P4
        local ao1 = ao_f(ao_vals[1])
        local ao2 = ao_f(ao_vals[2])
        local ao3 = ao_f(ao_vals[3])
        local ao4 = ao_f(ao_vals[4])

        local sun1, sun2, sun3, sun4
        local source1, source2, source3, source4

        -- If smooth light mode, light_vals contains array of 4 values each
        if type(light_vals[1]) == "table" then
            sun1, sun2, sun3, sun4 = light_vals[1][1] / 15.0, light_vals[1][2] / 15.0, light_vals[1][3] / 15.0,
                light_vals[1][4] / 15.0
            source1, source2, source3, source4 = light_vals[2][1] / 15.0, light_vals[2][2] / 15.0,
                light_vals[2][3] / 15.0,
                light_vals[2][4] / 15.0
        else
            sun1, sun2, sun3, sun4 = light_vals[1] / 15.0, light_vals[1] / 15.0, light_vals[1] / 15.0,
                light_vals[1] / 15.0
            source1, source2, source3, source4 = light_vals[2] / 15.0, light_vals[2] / 15.0, light_vals[2] / 15.0,
                light_vals[2] / 15.0
        end

        local uw, uh = uv_data.w, uv_data.h
        local wuh, huh = w * uw, h * uh

        local u1, v1, u2, v2, u3, v3, u4, v4
        if face_dir == 5 then
            u1, v1 = h * uw, 0
            u2, v2 = h * uw, w * uh
            u3, v3 = 0, w * uh
            u4, v4 = 0, 0
        elseif face_dir == 6 then
            u1, v1 = 0, w * uh
            u2, v2 = 0, 0
            u3, v3 = h * uw, 0
            u4, v4 = h * uw, w * uh
        else
            u1, v1 = 0, 0
            u2, v2 = wuh, 0
            u3, v3 = wuh, huh
            u4, v4 = 0, huh
        end

        -- V1 (P1)
        positions[base + 1] = p1x; positions[base + 2] = p1y; positions[base + 3] = p1z
        texcoord0[uv_base + 1] = u1; texcoord0[uv_base + 2] = v1
        colors[offset_base + 1] = ao1; colors[offset_base + 2] = source1; colors[offset_base + 3] = sun1; colors[offset_base + 4] = 1

        -- V2 (P2)
        positions[base + 4] = p2x; positions[base + 5] = p2y; positions[base + 6] = p2z
        texcoord0[uv_base + 3] = u2; texcoord0[uv_base + 4] = v2
        colors[offset_base + 5] = ao2; colors[offset_base + 6] = source2; colors[offset_base + 7] = sun2; colors[offset_base + 8] = 1

        -- V3 (P3)
        positions[base + 7] = p3x; positions[base + 8] = p3y; positions[base + 9] = p3z
        texcoord0[uv_base + 5] = u3; texcoord0[uv_base + 6] = v3
        colors[offset_base + 9] = ao3; colors[offset_base + 10] = source3; colors[offset_base + 11] = sun3; colors[offset_base + 12] = 1

        -- V4 (Same as V1/P1)
        positions[base + 10] = p1x; positions[base + 11] = p1y; positions[base + 12] = p1z
        texcoord0[uv_base + 7] = u1; texcoord0[uv_base + 8] = v1
        colors[offset_base + 13] = ao1; colors[offset_base + 14] = source1; colors[offset_base + 15] = sun1; colors[offset_base + 16] = 1

        -- V5 (Same as V3/P3)
        positions[base + 13] = p3x; positions[base + 14] = p3y; positions[base + 15] = p3z
        texcoord0[uv_base + 9] = u3; texcoord0[uv_base + 10] = v3
        colors[offset_base + 17] = ao3; colors[offset_base + 18] = source3; colors[offset_base + 19] = sun3; colors[offset_base + 20] = 1

        -- V6 (P4)
        positions[base + 16] = p4x; positions[base + 17] = p4y; positions[base + 18] = p4z
        texcoord0[uv_base + 11] = u4; texcoord0[uv_base + 12] = v4
        colors[offset_base + 21] = ao4; colors[offset_base + 22] = source4; colors[offset_base + 23] = sun4; colors[offset_base + 24] = 1


        -- Normals
        for i = 0, 5 do
            normals[base + i * 3 + 1] = nx
            normals[base + i * 3 + 2] = ny
            normals[base + i * 3 + 3] = nz
        end

        local uu, uv = uv_data.u, uv_data.v
        for i = 0, 5 do
            local off = offset_base + i * 4 + 1
            texcoord1[off] = uu
            texcoord1[off + 1] = uv
            texcoord1[off + 2] = uw
            texcoord1[off + 3] = uh
        end
        quad_idx = quad_idx + 1

        -- Build physical world edges for debug rendering (always cache, overlay decides when to draw)
        local wp1 = vmath.vector3(p1x + offset, p1y + offset, p1z + 490)
        local wp2 = vmath.vector3(p2x + offset, p2y + offset, p2z + 490)
        local wp3 = vmath.vector3(p3x + offset, p3y + offset, p3z + 490)
        local wp4 = vmath.vector3(p4x + offset, p4y + offset, p4z + 490)
        mesh_edges[#mesh_edges + 1] = { start_point = wp1, end_point = wp2, d = face_dir }
        mesh_edges[#mesh_edges + 1] = { start_point = wp2, end_point = wp3, d = face_dir }
        mesh_edges[#mesh_edges + 1] = { start_point = wp3, end_point = wp4, d = face_dir }
        mesh_edges[#mesh_edges + 1] = { start_point = wp4, end_point = wp1, d = face_dir }
    end

    for d = 1, 6 do
        for i = 0, grid_size - 1 do
            for m = 1, grid_size * grid_size do mask[m] = nil end

            -- Visibility Scan
            for j = 0, grid_size - 1 do
                for k = 0, grid_size - 1 do
                    local x, y, z, nx, ny, nz
                    if d == 1 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z + 1
                    elseif d == 2 then
                        x, y, z = k, j, i; nx, ny, nz = x, y, z - 1
                    elseif d == 3 then
                        x, y, z = k, i, j; nx, ny, nz = x, y + 1, z
                    elseif d == 4 then
                        x, y, z = k, i, j; nx, ny, nz = x, y - 1, z
                    elseif d == 5 then
                        x, y, z = i, k, j; nx, ny, nz = x + 1, y, z
                    elseif d == 6 then
                        x, y, z = i, k, j; nx, ny, nz = x - 1, y, z
                    end

                    local b_id = world.get_block(x, y, z)
                    local neighbor_id = get_block_local(self, nx, ny, nz)
                    local b_def = block_data.get_block(b_id)
                    local n_def = block_data.get_block(neighbor_id)

                    if b_def and not b_def.transparent then
                        if not n_def or n_def.transparent then
                            local ao_vals = calculate_ao(self, x, y, z, d, opaque_cache)
                            local a0, a1, a2, a3 = ao_vals[1], ao_vals[2], ao_vals[3], ao_vals[4]

                            -- Light Encoding
                            local sun_l, source_l = 15, 0
                            if self.light_mode == 0 or self.light_mode == 1 then -- Flat / Fake Smooth
                                sun_l, source_l = world.get_lights(nx, ny, nz)
                            end
                            local light_hash = sun_l + source_l * 16

                            -- Encode AO into mask.
                            local ao_hash = a0 + a1 * 4 + a2 * 16 + a3 * 64
                            mask[j * grid_size + k + 1] = b_id + ao_hash * 100000 + light_hash * 100000000
                        end
                    end
                end
            end

            -- Greedy Merge
            for j = 0, grid_size - 1 do
                local row_offset = j * grid_size
                for k = 0, grid_size - 1 do
                    local val = mask[row_offset + k + 1]
                    if val then
                        local lv = val % 100000000
                        local b_id = lv % 100000
                        local ao_hash = math.floor(lv / 100000)
                        local light_hash = math.floor(val / 100000000)

                        local sun_l = light_hash % 16
                        local source_l = math.floor(light_hash / 16)
                        local light_vals = { sun_l, source_l }

                        local a0 = ao_hash % 4
                        local a1 = math.floor(ao_hash / 4) % 4
                        local a2 = math.floor(ao_hash / 16) % 4
                        local a3 = math.floor(ao_hash / 64)

                        local w, h = 1, 1

                        while k + w < grid_size and mask[row_offset + k + w + 1] == val do w = w + 1 end
                        local can_expand_h = true
                        while j + h < grid_size do
                            local next_row_offset = (j + h) * grid_size
                            for r = 0, w - 1 do
                                if mask[next_row_offset + k + r + 1] ~= val then
                                    can_expand_h = false; break
                                end
                            end
                            if not can_expand_h then break end
                            h = h + 1
                        end

                        local ao_vals = { a0, a1, a2, a3 }
                        local b_def = block_data.get_block(b_id)
                        local uv_data = b_def and b_def.uvs and b_def.uvs[d]
                        if uv_data then
                            local s_vals = { sun_l, source_l }

                            if self.light_mode == 1 then
                                -- SMOOTH LIGHTING calculations for the 4 corners (P1, P2, P3, P4)
                                -- Calculate exact averaged corner lighting here (since greedy is disabled)
                                local cx, cy, cz = 0, 0, 0
                                if d == 1 then
                                    cx, cy, cz = k, j, i + 1
                                elseif d == 2 then
                                    cx, cy, cz = k, j, i - 1
                                elseif d == 3 then
                                    cx, cy, cz = k, i + 1, j
                                elseif d == 4 then
                                    cx, cy, cz = k, i - 1, j
                                elseif d == 5 then
                                    cx, cy, cz = i + 1, k, j
                                elseif d == 6 then
                                    cx, cy, cz = i - 1, k, j
                                end

                                local function get_smooth_l(px, py, pz, dx1, dy1, dz1, dx2, dy2, dz2, dx3, dy3, dz3)
                                    local l1_sun, l1_source = world.get_lights(px, py, pz)
                                    local l2_sun, l2_source = world.get_lights(px + dx1, py + dy1, pz + dz1)
                                    local l3_sun, l3_source = world.get_lights(px + dx2, py + dy2, pz + dz2)
                                    local l4_sun, l4_source = world.get_lights(px + dx3, py + dy3, pz + dz3)
                                    return (l1_sun + l2_sun + l3_sun + l4_sun) / 4.0,
                                        (l1_source + l2_source + l3_source + l4_source) / 4.0
                                end

                                local s_sun, s_source = { 0, 0, 0, 0 }, { 0, 0, 0, 0 }

                                -- To support greedy meshing corners, we use w and h dynamically to grab the far edges
                                if d == 1 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx, cy, cz, 0, -1, 0, -1, 0, 0, -1, -1, 0)
                                    s_sun[2], s_source[2] = get_smooth_l(cx + w - 1, cy, cz, 1, 0, 0, 0, -1, 0, 1, -1, 0)
                                    s_sun[3], s_source[3] = get_smooth_l(cx + w - 1, cy + h - 1, cz, 1, 0, 0, 0, 1, 0, 1,
                                        1,
                                        0)
                                    s_sun[4], s_source[4] = get_smooth_l(cx, cy + h - 1, cz, -1, 0, 0, 0, 1, 0, -1, 1, 0)
                                elseif d == 2 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx + w - 1, cy, cz, 1, 0, 0, 0, -1, 0, 1, -1, 0)
                                    s_sun[2], s_source[2] = get_smooth_l(cx, cy, cz, -1, 0, 0, 0, -1, 0, -1, -1, 0)
                                    s_sun[3], s_source[3] = get_smooth_l(cx, cy + h - 1, cz, -1, 0, 0, 0, 1, 0, -1, 1, 0)
                                    s_sun[4], s_source[4] = get_smooth_l(cx + w - 1, cy + h - 1, cz, 1, 0, 0, 0, 1, 0, 1,
                                        1,
                                        0)
                                elseif d == 3 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx, cy, cz + h - 1, -1, 0, 0, 0, 0, 1, -1, 0, 1)
                                    s_sun[2], s_source[2] = get_smooth_l(cx + w - 1, cy, cz + h - 1, 1, 0, 0, 0, 0, 1, 1,
                                        0,
                                        1)
                                    s_sun[3], s_source[3] = get_smooth_l(cx + w - 1, cy, cz, 1, 0, 0, 0, 0, -1, 1, 0, -1)
                                    s_sun[4], s_source[4] = get_smooth_l(cx, cy, cz, -1, 0, 0, 0, 0, -1, -1, 0, -1)
                                elseif d == 4 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx, cy, cz, -1, 0, 0, 0, 0, -1, -1, 0, -1)
                                    s_sun[2], s_source[2] = get_smooth_l(cx + w - 1, cy, cz, 1, 0, 0, 0, 0, -1, 1, 0, -1)
                                    s_sun[3], s_source[3] = get_smooth_l(cx + w - 1, cy, cz + h - 1, 1, 0, 0, 0, 0, 1, 1,
                                        0,
                                        1)
                                    s_sun[4], s_source[4] = get_smooth_l(cx, cy, cz + h - 1, -1, 0, 0, 0, 0, 1, -1, 0, 1)
                                elseif d == 5 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx, cy, cz, 0, -1, 0, 0, 0, -1, 0, -1, -1)
                                    s_sun[2], s_source[2] = get_smooth_l(cx, cy + w - 1, cz, 0, 1, 0, 0, 0, -1, 0, 1, -1)
                                    s_sun[3], s_source[3] = get_smooth_l(cx, cy + w - 1, cz + h - 1, 0, 1, 0, 0, 0, 1, 0,
                                        1,
                                        1)
                                    s_sun[4], s_source[4] = get_smooth_l(cx, cy, cz + h - 1, 0, -1, 0, 0, 0, 1, 0, -1, 1)
                                elseif d == 6 then
                                    s_sun[1], s_source[1] = get_smooth_l(cx, cy + w - 1, cz, 0, 1, 0, 0, 0, -1, 0, 1, -1)
                                    s_sun[2], s_source[2] = get_smooth_l(cx, cy, cz, 0, -1, 0, 0, 0, -1, 0, -1, -1)
                                    s_sun[3], s_source[3] = get_smooth_l(cx, cy, cz + h - 1, 0, -1, 0, 0, 0, 1, 0, -1, 1)
                                    s_sun[4], s_source[4] = get_smooth_l(cx, cy + w - 1, cz + h - 1, 0, 1, 0, 0, 0, 1, 0,
                                        1,
                                        1)
                                end
                                s_vals = { s_sun, s_source }
                            end

                            if d == 1 then
                                -- P1, P2, P3, P4 matches calc_aoD1
                                add_quad(k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j + h -
                                    0.5, i + 0.5, k - 0.5, j + h - 0.5, i + 0.5, uv_data, w, h, 0, 0, 1, ao_vals,
                                    s_vals, d)
                            elseif d == 2 then
                                add_quad(k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5, j + h - 0.5,
                                    i - 0.5, k + w - 0.5, j + h - 0.5, i - 0.5, uv_data, w, h, 0, 0, -1, ao_vals,
                                    s_vals, d)
                            elseif d == 3 then
                                add_quad(k - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5, i + 0.5, j + h - 0.5, k + w - 0.5,
                                    i + 0.5, j - 0.5, k - 0.5, i + 0.5, j - 0.5, uv_data, w, h, 0, 1, 0, ao_vals,
                                    s_vals, d)
                            elseif d == 4 then
                                add_quad(k - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5, j - 0.5, k + w - 0.5, i - 0.5,
                                    j + h - 0.5, k - 0.5, i - 0.5, j + h - 0.5, uv_data, w, h, 0, -1, 0, ao_vals,
                                    s_vals, d)
                            elseif d == 5 then
                                add_quad(i + 0.5, k - 0.5, j - 0.5, i + 0.5, k + w - 0.5, j - 0.5, i + 0.5, k + w - 0.5,
                                    j + h - 0.5, i + 0.5, k - 0.5, j + h - 0.5, uv_data, w, h, 1, 0, 0, ao_vals,
                                    s_vals, d)
                            elseif d == 6 then
                                add_quad(i - 0.5, k + w - 0.5, j - 0.5, i - 0.5, k - 0.5, j - 0.5, i - 0.5, k - 0.5,
                                    j + h - 0.5, i - 0.5, k + w - 0.5, j + h - 0.5, uv_data, w, h, -1, 0, 0, ao_vals,
                                    s_vals, d)
                            end
                            greedy_faces = greedy_faces + 1
                        end

                        for r = 0, h - 1 do
                            local proc_row_offset = (j + r) * grid_size
                            for c = 0, w - 1 do mask[proc_row_offset + k + c + 1] = nil end
                        end
                    end
                end
            end
        end
    end

    local current_vertex_count = quad_idx * 18
    local prev_vertex_count = self.prev_vertex_count or 0
    if prev_vertex_count > current_vertex_count then
        for i = current_vertex_count + 1, prev_vertex_count do positions[i] = 0 end
    end
    self.prev_vertex_count = current_vertex_count
    _G.stats_faces = greedy_faces
    _G.stats_vertices = quad_idx * 4
    resource.set_buffer(self.buffer_resource, self.buf)
    go.set(self.mesh_url, H_VERTICES, self.buffer_resource)

    -- Cache edges globally for the performance overlay to read directly
    _G.cached_mesh_edges = mesh_edges

    _G.stats_mesh_build_time = (os.clock() - start_time) * 1000
end

local function create_chunk(self)
    local mesh_go = create_mesh(self)
    local grid_size = self.grid_size
    _G.grid_size = grid_size
    local num_cubes = grid_size * grid_size * grid_size

    local atlas = resource.get_atlas(self.game_atlas)
    go.set(mesh_go.mesh_url, H_TEXTURE0, hash(atlas.texture))
    go.set(mesh_go.mesh_url, hash("texture1"), self.breaking_texture)

    block_data.init(self.game_atlas)

    self.mask = {}
    for i = 1, grid_size * grid_size do self.mask[i] = false end

    local max_faces   = num_cubes * 3
    local buf         = buffer.create(max_faces * 6, {
        { name = H_POSITION,  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = H_TEXCOORD0, type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = H_TEXCOORD1, type = buffer.VALUE_TYPE_FLOAT32, count = 4 },
        { name = H_NORMAL,    type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = H_COLOR,     type = buffer.VALUE_TYPE_FLOAT32, count = 4 }
    })

    self.buf          = buf
    self.positions    = buffer.get_stream(buf, H_POSITION)
    self.texcoord0    = buffer.get_stream(buf, H_TEXCOORD0)
    self.texcoord1    = buffer.get_stream(buf, H_TEXCOORD1)
    self.normals      = buffer.get_stream(buf, H_NORMAL)
    self.colors       = buffer.get_stream(buf, H_COLOR)

    -- Removed self.world assignment, accessing world.data directly or via get_block
    self.total_cubes  = 0
    _G.shared_cubemap = {}
    for cx = 0, grid_size - 1 do
        for cy = 0, grid_size - 1 do
            for cz = 0, grid_size - 1 do
                if world.get_block(cx, cy, cz) ~= 0 then
                    self.total_cubes = self.total_cubes + 1
                    local cube_idx = cx + cy * grid_size + cz * grid_size * grid_size
                    _G.shared_cubemap[cube_idx] = true
                end
            end
        end
    end

    self.mesh_url = mesh_go.mesh_url
    _G.terrain_mesh_url = mesh_go.mesh_url
    self.buffer_resource = resource.create_buffer(string.format(PATCH_BUFFER, 7), { buffer = buf })

    update_mesh(self)

    local offset = -self.grid_size / 2 + 0.5
    go.set_position(vmath.vector3(offset, offset, 490), mesh_go.go_id)
end

function init(self)
    local grid_size = self.grid_size

    self.ao_enabled = true -- Default On
    self.light_mode = 1    -- 0: Flat, 1: Smooth, 2: Off
    _G.ao_enabled = true
    _G.light_mode = 1
    self.block_entities = {} -- Generic map: "gx_gy_gz" -> go_id (torches, etc.)

    -- Initialize global world
    world.init(grid_size)

    math.randomseed(os.time())

    for cx = 0, grid_size - 1 do
        for cy = 0, grid_size - 1 do
            for cz = 0, grid_size - 1 do
                local block_id = 0
                if cy == 0 then
                    block_id = 2 -- Unbreakable layer
                elseif cy == grid_size - 1 then
                    block_id = 5 -- Grass
                elseif cy >= grid_size - 4 then
                    block_id = 6 -- Dirt
                else
                    if math.random() < 0.3 then
                        block_id = 3 -- Golden Ore
                    else
                        block_id = 1 -- Stone
                    end
                end
                world.set_block(cx, cy, cz, block_id)
            end
        end
    end

    create_chunk(self) -- Removed world_data argument
    self.time = 0

    -- Listen for AO toggle
    msg.post(".", "acquire_input_focus")
end

function on_message(self, message_id, message, sender)
    if message_id == H_DESTROY_CUBE then
        local gx, gy, gz = message.gx, message.gy, message.gz
        if gx and gy and gz and self.grid_size then
            local b_id = world.get_block(gx, gy, gz)
            if b_id ~= 0 and b_id ~= 2 then -- Not air and not unbreakable
                -- Optimized sound trigger with reused vector
                local offset = -self.grid_size / 2 + 0.5
                TEMP_POS.x = offset + gx
                TEMP_POS.y = offset + gy
                TEMP_POS.z = 490 + gz

                local b_def = block_data.get_block(b_id)
                if b_def and b_def.break_sound then
                    sm.play(b_def.break_sound, 1.0, TEMP_POS)
                else
                    sm.play(sm.stone_debris, 1.0, TEMP_POS)
                end

                world.set_block(gx, gy, gz, 0)

                -- Remove any attached entity (torch, etc.)
                local e_key = gx .. "_" .. gy .. "_" .. gz
                if self.block_entities[e_key] then
                    go.delete(self.block_entities[e_key])
                    self.block_entities[e_key] = nil
                end

                self.total_cubes = (self.total_cubes or 1) - 1
                local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                world.recalculate_lighting()
                update_mesh(self)
            end
        end
    elseif message_id == H_PLACE_CUBE then
        local gx, gy, gz = message.gx, message.gy, message.gz
        local target_id = message.block_id or 1
        if gx and gy and gz and self.grid_size then
            if gx >= 0 and gx < self.grid_size and gy >= 0 and gy < self.grid_size and gz >= 0 and gz < self.grid_size then
                if world.get_block(gx, gy, gz) == 0 then
                    world.set_block(gx, gy, gz, target_id)

                    if target_id == 12 and self.torch_factory then
                        local offset = -self.grid_size / 2 + 0.5
                        local pos = vmath.vector3(offset + gx, offset + gy, 490 + gz)
                        local t_id = factory.create(self.torch_factory, pos)
                        self.block_entities[gx .. "_" .. gy .. "_" .. gz] = t_id
                        -- Explicitly set tint to white so the torch is fully visible/bright as a light source
                        pcall(function() go.set(msg.url(nil, t_id, "model"), "tint", vmath.vector4(1, 1, 1, 1)) end)
                        sm.play(sm.place, 1.0, pos)
                    else
                        local offset = -self.grid_size / 2 + 0.5
                        local pos = vmath.vector3(offset + gx, offset + gy, 490 + gz)
                        sm.play(sm.place, 1.0, pos)
                    end

                    self.total_cubes = (self.total_cubes or 0) + 1
                    local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                    world.recalculate_lighting()
                    update_mesh(self)
                end
            end
        end
    elseif message_id == hash("set_blocks_area") then
        local center_gx, center_gy, center_gz = message.gx, message.gy, message.gz
        local radius = message.radius or 1
        local target_id = message.block_id or 0
        local modified = false

        if center_gx and center_gy and center_gz and self.grid_size then
            local offset = -self.grid_size / 2 + 0.5
            for gx = center_gx - radius, center_gx + radius do
                for gy = center_gy - radius, center_gy + radius do
                    for gz = center_gz - radius, center_gz + radius do
                        -- Bound checking within grid and above unbreakable layer
                        if gx >= 0 and gx < self.grid_size and
                            gy > 0 and gy < self.grid_size and
                            gz >= 0 and gz < self.grid_size then
                            local current_id = world.get_block(gx, gy, gz)
                            if current_id ~= target_id and current_id ~= 2 then -- Don't break unbreakable (2)
                                world.set_block(gx, gy, gz, target_id)

                                local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                                if target_id == 0 then
                                    if current_id ~= 0 then self.total_cubes = (self.total_cubes or 1) - 1 end
                                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                                    -- Remove any attached entity at this position
                                    local e_key = gx .. "_" .. gy .. "_" .. gz
                                    if self.block_entities[e_key] then
                                        print("Deleting entity at " .. e_key)
                                        pcall(go.delete, self.block_entities[e_key])
                                        self.block_entities[e_key] = nil
                                    end

                                    -- Play debris sound (Throttled by Sound Manager)
                                    TEMP_POS.x = offset + gx
                                    TEMP_POS.y = offset + gy
                                    TEMP_POS.z = 490 + gz
                                    sm.play(sm.stone_debris, 1.0, TEMP_POS)
                                else
                                    if current_id == 0 then self.total_cubes = (self.total_cubes or 0) + 1 end
                                    if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                                end
                                modified = true
                            end
                        end
                    end
                end
            end
            if modified then
                world.recalculate_lighting()
                update_mesh(self)
            end
        end
    elseif message_id == hash("set_blocks_list") then
        local blocks = message.blocks
        local modified = false
        if blocks and self.grid_size then
            local offset = -self.grid_size / 2 + 0.5
            for _, b in ipairs(blocks) do
                local gx, gy, gz, target_id = b.gx, b.gy, b.gz, b.id or 0
                if gx and gy and gz then
                    if gx >= 0 and gx < self.grid_size and
                        gy > 0 and gy < self.grid_size and
                        gz >= 0 and gz < self.grid_size then
                        local current_id = world.get_block(gx, gy, gz)
                        if current_id ~= target_id and current_id ~= 2 then
                            world.set_block(gx, gy, gz, target_id)

                            local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
                            if target_id == 0 then
                                if current_id ~= 0 then self.total_cubes = (self.total_cubes or 1) - 1 end
                                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = false end
                                -- Remove any attached entity at this position
                                local e_key = gx .. "_" .. gy .. "_" .. gz
                                if self.block_entities[e_key] then
                                    go.delete(self.block_entities[e_key])
                                    self.block_entities[e_key] = nil
                                end

                                -- Play debris sound (Throttled by Sound Manager)
                                TEMP_POS.x = offset + gx
                                TEMP_POS.y = offset + gy
                                TEMP_POS.z = 490 + gz
                                sm.play(sm.stone_debris, 1.0, TEMP_POS)
                            else
                                if current_id == 0 then self.total_cubes = (self.total_cubes or 0) + 1 end
                                if _G.shared_cubemap then _G.shared_cubemap[cube_idx] = true end
                            end
                            modified = true
                        end
                    end
                end
            end
            if modified then
                world.recalculate_lighting()
                update_mesh(self)
            end
        end
    elseif message_id == H_TOGGLE_AO then
        self.ao_enabled = not self.ao_enabled
        _G.ao_enabled = self.ao_enabled
        update_mesh(self)
        print("AO Enabled: " .. tostring(self.ao_enabled))
    elseif message_id == H_TOGGLE_LIGHT_MODE then
        self.light_mode = (self.light_mode + 1) % 3
        _G.light_mode = self.light_mode
        update_mesh(self)
        local modes = { "Flat", "Smooth", "Off" }
        print("Lighting Mode: " .. modes[self.light_mode + 1])
    end
end

function final(self)
    resource.release(string.format(PATCH_BUFFER, 7))
end
