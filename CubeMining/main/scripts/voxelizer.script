-- voxelizer.script

local ITEMS = {
    { id = "gun",     path = "/assets/images/items/gun.png" },
    { id = "pickaxe", path = "/assets/images/items/pickaxe.png" },
    { id = "sword",   path = "/assets/images/items/sword.png" }
}

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("depth", 0.5)

local function get_pixel(img, x, y)
    if x < 0 or x >= img.width or y < 0 or y >= img.height then return 0, 0, 0, 0 end
    local index = (y * img.width + x) * 4 + 1
    return string.byte(img.buffer, index, index + 3)
end

local function add_v(pos, uv0, uv1, x, y, z, u, v, mu, mv, mw, mh)
    table.insert(pos, x); table.insert(pos, y); table.insert(pos, z)
    table.insert(uv0, u); table.insert(uv0, v)
    table.insert(uv1, mu); table.insert(uv1, mv); table.insert(uv1, mw); table.insert(uv1, mh)
end

local function add_face(pos, uv0, uv1, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, metadata, u1, v1, u2, v2, u3, v3, u4, v4)
    local mu, mv, mw, mh = metadata.u, metadata.v, metadata.w, metadata.h
    -- T1: v1, v2, v3
    add_v(pos, uv0, uv1, x1, y1, z1, u1, v1, mu, mv, mw, mh)
    add_v(pos, uv0, uv1, x2, y2, z2, u2, v2, mu, mv, mw, mh)
    add_v(pos, uv0, uv1, x3, y3, z3, u3, v3, mu, mv, mw, mh)
    -- T2: v1, v3, v4
    add_v(pos, uv0, uv1, x1, y1, z1, u1, v1, mu, mv, mw, mh)
    add_v(pos, uv0, uv1, x3, y3, z3, u3, v3, mu, mv, mw, mh)
    add_v(pos, uv0, uv1, x4, y4, z4, u4, v4, mu, mv, mw, mh)
end

local function build_voxel_mesh(self, item_index)
    local start_time = os.clock()
    local item = ITEMS[item_index]
    local img_data = sys.load_resource(item.path)
    if not img_data then img_data = sys.load_resource(string.sub(item.path, 2)) end
    if not img_data then return end

    local img = image.load(img_data)
    local width, height, depth = img.width, img.height, self.depth
    local atlas = resource.get_atlas(self.game_atlas)
    local texture_info = resource.get_texture_info(atlas.texture)

    local metadata = { u = 0, v = 0, w = 1, h = 1 }
    for i, animation in ipairs(atlas.animations) do
        if animation.id == hash(item.id) then
            local geom = atlas.geometries[i]
            local min_u, max_u, min_v, max_v = math.huge, -math.huge, math.huge, -math.huge
            for j = 1, #geom.uvs, 2 do
                local u, v = geom.uvs[j], geom.uvs[j + 1]
                min_u = math.min(min_u, u); max_u = math.max(max_u, u)
                min_v = math.min(min_v, v); max_v = math.max(max_v, v)
            end
            metadata = {
                u = min_u / texture_info.width,
                v = (texture_info.height - max_v) / texture_info.height,
                w = (max_u - min_u) / texture_info.width,
                h = (max_v - min_v) / texture_info.height
            }
            break
        end
    end

    local pos, uv0, uv1 = {}, {}, {}
    local ox, oy = -width / 2, -height / 2

    -- Front face (+Z)
    add_face(pos, uv0, uv1, 
        ox, oy, depth, ox + width, oy, depth, ox + width, oy + height, depth, ox, oy + height, depth,
        metadata, 0, 0, metadata.w, 0, metadata.w, metadata.h, 0, metadata.h)
    
    -- Back face (-Z)
    add_face(pos, uv0, uv1,
        ox + width, oy, 0, ox, oy, 0, ox, oy + height, 0, ox + width, oy + height, 0,
        metadata, metadata.w, 0, 0, 0, 0, metadata.h, metadata.w, metadata.h)

    local du, dv = metadata.w / width, metadata.h / height
    for x = 0, width - 1 do
        for y = 0, height - 1 do
            local _, _, _, a = get_pixel(img, x, y)
            if a > 128 then
                local pu, pv = (x + 0.5) * du, (height - 1 - y + 0.5) * dv
                -- Meta for sides: single pixel area
                local pm = { u = metadata.u + pu, v = metadata.v + pv, w = 0.0001, h = 0.0001 }
                -- Left
                if get_pixel(img, x - 1, y) < 128 then
                    add_face(pos, uv0, uv1, ox + x, oy + height - 1 - y, 0, ox + x, oy + height - 1 - y, depth,
                            ox + x, oy + height - y, depth, ox + x, oy + height - y, 0, pm, 0,0,0,0,0,0,0,0)
                end
                -- Right
                if get_pixel(img, x + 1, y) < 128 then
                    add_face(pos, uv0, uv1, ox + x + 1, oy + height - 1 - y, depth, ox + x + 1, oy + height - 1 - y, 0,
                            ox + x + 1, oy + height - y, 0, ox + x + 1, oy + height - y, depth, pm, 0,0,0,0,0,0,0,0)
                end
                -- Top
                if get_pixel(img, x, y - 1) < 128 then
                    add_face(pos, uv0, uv1, ox + x, oy + height - y, depth, ox + x + 1, oy + height - y, depth,
                            ox + x + 1, oy + height - y, 0, ox + x, oy + height - y, 0, pm, 0,0,0,0,0,0,0,0)
                end
                -- Bottom
                if get_pixel(img, x, y + 1) < 128 then
                    add_face(pos, uv0, uv1, ox + x, oy + height - 1 - y, 0, ox + x + 1, oy + height - 1 - y, 0,
                            ox + x + 1, oy + height - 1 - y, depth, ox + x, oy + height - 1 - y, depth, pm, 0,0,0,0,0,0,0,0)
                end
            end
        end
    end

    local buf = buffer.create(#pos / 3, {
        { name = hash("position"),  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = hash("texcoord0"), type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = hash("texcoord1"), type = buffer.VALUE_TYPE_FLOAT32, count = 4 }
    })
    local ps, u0, u1 = buffer.get_stream(buf, "position"), buffer.get_stream(buf, "texcoord0"), buffer.get_stream(buf, "texcoord1")
    for i = 1, #pos do ps[i] = pos[i] end
    for i = 1, #uv0 do u0[i] = uv0[i] end
    for i = 1, #uv1 do u1[i] = uv1[i] end

    if not self.held_mesh_url then
        local h_id = factory.create(self.mesh_prefab); self.held_mesh_url = msg.url(h_id); self.held_mesh_url.fragment = hash("mesh")
        go.set(self.held_mesh_url, "texture0", hash(atlas.texture)); go.set_position(vmath.vector3(0.4, -0.4, -0.8), h_id)
        go.set_scale(vmath.vector3(0.04, 0.04, 0.04), h_id); go.set_parent(h_id, go.get_id())
        local w_id = factory.create(self.mesh_prefab); self.world_mesh_url = msg.url(w_id); self.world_mesh_url.fragment = hash("mesh")
        go.set(self.world_mesh_url, "texture0", hash(atlas.texture)); go.set_position(vmath.vector3(0, 10, 500), w_id); go.set_scale(vmath.vector3(0.5, 0.5, 0.5), w_id)
    end
    local res = resource.create_buffer("/item_" .. item.id .. ".bufferc", { buffer = buf })
    go.set(self.held_mesh_url, "vertices", res); go.set(self.world_mesh_url, "vertices", res)
    _G.item_mesh_build_time = (os.clock() - start_time) * 1000
end

function init(self)
    self.current_item = 1; msg.post(".", "acquire_input_focus"); msg.post(".", "build_item")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("build_item") then build_voxel_mesh(self, self.current_item) end
end

function on_input(self, action_id, action)
    if action_id == hash("key_q") and action.pressed then
        self.current_item = (self.current_item % #ITEMS) + 1
        build_voxel_mesh(self, self.current_item)
    end
end
