-- voxelizer.script
-- Converts 2D sprites into 3D voxel models with perfect UV alignment and transparency.

local ITEMS = {
    { id = "gun",     path = "/assets/images/items/gun.png" },
    { id = "pickaxe", path = "/assets/images/items/pickaxe.png" },
    { id = "sword",   path = "/assets/images/items/sword.png" },
    { id = "16x16",   path = "/assets/images/items/16x16.png" },
    { id = "64x64",   path = "/assets/images/items/64x64.png" }
}

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("depth", 0.5)
go.property("sway_pivot", msg.url())

-- Reads RGBA from image buffer
local function get_pixel(img, x, y)
    if x < 0 or x >= img.width or y < 0 or y >= img.height then return 0, 0, 0, 0 end
    local index = (y * img.width + x) * 4 + 1
    return string.byte(img.buffer, index, index + 3)
end

-- Adds a vertex with tiling UVs (texcoord0) and atlas metadata (texcoord1)
local function add_v(pos, uv0, uv1, x, y, z, u, v, metadata)
    table.insert(pos, x); table.insert(pos, y); table.insert(pos, z)
    -- texcoord0: normalized 0..1 coordinates within the atlas sub-region
    table.insert(uv0, u); table.insert(uv0, v)
    -- texcoord1: atlas metadata [u, v, width, height]
    table.insert(uv1, metadata.u); table.insert(uv1, metadata.v); table.insert(uv1, metadata.w); table.insert(uv1,
        metadata.h)
end

-- Adds a quad consisting of 2 triangles (CCW winding)
local function add_face(pos, uv0, uv1, x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, metadata, u1, v1, u2, v2, u3, v3,
                        u4, v4)
    add_v(pos, uv0, uv1, x1, y1, z1, u1, v1, metadata)
    add_v(pos, uv0, uv1, x2, y2, z2, u2, v2, metadata)
    add_v(pos, uv0, uv1, x3, y3, z3, u3, v3, metadata)
    add_v(pos, uv0, uv1, x1, y1, z1, u1, v1, metadata)
    add_v(pos, uv0, uv1, x3, y3, z3, u3, v3, metadata)
    add_v(pos, uv0, uv1, x4, y4, z4, u4, v4, metadata)
end

function build_voxel_mesh(self, item_index)
    local start_time = os.clock()
    local item = ITEMS[item_index]

    local img_data = sys.load_resource(item.path)
    if not img_data then img_data = sys.load_resource(string.sub(item.path, 2)) end
    if not img_data then return end

    local img = image.load(img_data)
    local width, height, depth = img.width, img.height, self.depth
    local atlas_res = resource.get_atlas(self.game_atlas)
    local tex_info = resource.get_texture_info(atlas_res.texture)

    -- Item atlas bounds metadata
    local metadata = { u = 0, v = 0, w = 1, h = 1 }
    for i, animation in ipairs(atlas_res.animations) do
        local anim_id = type(animation.id) == "string" and hash(animation.id) or animation.id
        if anim_id == hash(item.id) then
            local geom = atlas_res.geometries[i]
            local min_u, max_u, min_v, max_v = math.huge, -math.huge, math.huge, -math.huge
            for j = 1, #geom.uvs, 2 do
                local u, v = geom.uvs[j], geom.uvs[j + 1]
                min_u = math.min(min_u, u); max_u = math.max(max_u, u)
                min_v = math.min(min_v, v); max_v = math.max(max_v, v)
            end
            metadata = {
                u = min_u / tex_info.width,
                v = (tex_info.height - max_v) / tex_info.height,
                w = (max_u - min_u) / tex_info.width,
                h = (max_v - min_v) / tex_info.height
            }
            break
        end
    end

    local positions, uv0, uv1 = {}, {}, {}
    local ox, oy = -width / 2, -height / 2

    -- FRONT FACE (+Z): Map quad vertices to 0..1 range
    add_face(positions, uv0, uv1,
        ox, oy, depth, ox + width, oy, depth, ox + width, oy + height, depth, ox, oy + height, depth,
        metadata, 0, 0, 1, 0, 1, 1, 0, 1)

    -- BACK FACE (-Z): Mirrored quad mapping
    add_face(positions, uv0, uv1,
        ox + width, oy, 0, ox, oy, 0, ox, oy + height, 0, ox + width, oy + height, 0,
        metadata, 1, 0, 0, 0, 0, 1, 1, 1)

    -- SIDES: Pixel extrusion
    for x = 0, width - 1 do
        for y = 0, height - 1 do
            local _, _, _, a = get_pixel(img, x, y)
            if a > 128 then
                -- Map side face to the exact center of its source pixel [0..1]
                local pu = (x + 0.5) / width
                local pv = (height - 1 - y + 0.5) / height

                -- Detect edges and add side faces pointing to (pu, pv)
                if select(4, get_pixel(img, x - 1, y)) < 128 then -- Left
                    add_face(positions, uv0, uv1, ox + x, oy + height - 1 - y, 0, ox + x, oy + height - 1 - y, depth,
                        ox + x, oy + height - y, depth, ox + x, oy + height - y, 0, metadata, pu, pv, pu, pv, pu, pv, pu,
                        pv)
                end
                if select(4, get_pixel(img, x + 1, y)) < 128 then -- Right
                    add_face(positions, uv0, uv1, ox + x + 1, oy + height - 1 - y, depth, ox + x + 1, oy + height - 1 - y,
                        0,
                        ox + x + 1, oy + height - y, 0, ox + x + 1, oy + height - y, depth, metadata, pu, pv, pu, pv, pu,
                        pv, pu, pv)
                end
                if select(4, get_pixel(img, x, y - 1)) < 128 then -- Top
                    add_face(positions, uv0, uv1, ox + x, oy + height - y, depth, ox + x + 1, oy + height - y, depth,
                        ox + x + 1, oy + height - y, 0, ox + x, oy + height - y, 0, metadata, pu, pv, pu, pv, pu, pv, pu,
                        pv)
                end
                if select(4, get_pixel(img, x, y + 1)) < 128 then -- Bottom
                    add_face(positions, uv0, uv1, ox + x, oy + height - 1 - y, 0, ox + x + 1, oy + height - 1 - y, 0,
                        ox + x + 1, oy + height - 1 - y, depth, ox + x, oy + height - 1 - y, depth, metadata, pu, pv, pu,
                        pv, pu, pv, pu, pv)
                end
            end
        end
    end

    -- Create/Update buffer with standard layout
    local buf = buffer.create(#positions / 3, {
        { name = hash("position"),  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = hash("texcoord0"), type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = hash("texcoord1"), type = buffer.VALUE_TYPE_FLOAT32, count = 4 }
    })
    local ps, u0, u1 = buffer.get_stream(buf, "position"), buffer.get_stream(buf, "texcoord0"),
        buffer.get_stream(buf, "texcoord1")
    for i = 1, #positions do ps[i] = positions[i] end
    for i = 1, #uv0 do u0[i] = uv0[i] end
    for i = 1, #uv1 do u1[i] = uv1[i] end

    -- Initialize visual objects once and update their vertices
    if not self.held_mesh_url then
        local h_id = factory.create(self.mesh_prefab); self.held_mesh_url = msg.url(h_id); self.held_mesh_url.fragment =
        hash("mesh")
        go.set(self.held_mesh_url, "texture0", hash(atlas_res.texture))

        -- Hand position and permanent rotation (15 deg right)
        go.set_position(vmath.vector3(0.4, -0.4, -0.8), h_id)
        go.set_rotation(vmath.quat_rotation_y(0.26) * vmath.quat_rotation_x(-0.2), h_id)

        -- Reduced scale (from 0.026 to 0.017)
        go.set_scale(vmath.vector3(0.017, 0.017, 0.017), h_id)

        -- Parenting to sway pivot or camera
        local pivot = self.sway_pivot
        if pivot.path == hash("") then pivot = go.get_id() end
        go.set_parent(h_id, pivot)

        local w_id = factory.create(self.mesh_prefab); self.world_mesh_url = msg.url(w_id); self.world_mesh_url.fragment =
        hash("mesh")
        go.set(self.world_mesh_url, "texture0", hash(atlas_res.texture))
        go.set_position(vmath.vector3(0, 10, 500), w_id); go.set_scale(vmath.vector3(0.05, 0.05, 0.05), w_id)

        self.item_buffers = {} -- Cache for buffer resource handles
    end

    local path = "/item_" .. item.id .. ".bufferc"
    local res = self.item_buffers[item.id]
    if not res then
        res = resource.create_buffer(path, { buffer = buf })
        self.item_buffers[item.id] = res
    else
        resource.set_buffer(res, buf)
    end

    go.set(self.held_mesh_url, "vertices", res); go.set(self.world_mesh_url, "vertices", res)
    _G.item_mesh_build_time = (os.clock() - start_time) * 1000
end

function init(self)
    self.current_item = 1; msg.post(".", "acquire_input_focus"); msg.post(".", "build_item")
end

function on_message(self, message_id, message, sender)
    if message_id == hash("build_item") then build_voxel_mesh(self, self.current_item) end
end

function on_input(self, action_id, action)
    -- Cycle items: Gun (1) -> Pickaxe (2) -> Sword (3) -> 16x16 -> 64x64 -> Gun
    if action_id == hash("key_q") and action.pressed then
        self.current_item = (self.current_item % #ITEMS) + 1
        build_voxel_mesh(self, self.current_item)
    end
end
