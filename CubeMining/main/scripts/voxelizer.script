-- voxelizer.script
-- Optimized runtime 2D-to-3D voxelization system.
-- Uses direct buffer stream writing and metadata caching for performance.

-- Cache engine modules for faster access
local vmath = vmath
local resource = resource
local buffer = buffer
local go = go
local msg = msg
local factory = factory
local sys = sys
local image = image
local hash = hash

local H_POSITION = hash("position")
local H_TEXCOORD0 = hash("texcoord0")
local H_TEXCOORD1 = hash("texcoord1")
local H_NORMAL = hash("normal")
local H_TEXTURE0 = hash("texture0")
local H_VERTICES = hash("vertices")
local H_BUILD_ITEM = hash("build_item")
local H_SWITCH_ITEM = hash("switch_item")
local H_ACQUIRE_INPUT_FOCUS = hash("acquire_input_focus")
local H_MESH = hash("mesh")

local ITEMS = {
    { id = hash("gun"),     path = "/assets/images/items/gun.png" },
    { id = hash("pickaxe"), path = "/assets/images/items/pickaxe.png" },
    { id = hash("sword"),   path = "/assets/images/items/sword.png" },
    { id = hash("16x16"),   path = "/assets/images/items/16x16.png" },
    { id = hash("64x64"),   path = "/assets/images/items/64x64.png" }
}

go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("depth", 0.5)
go.property("sway_pivot", msg.url())

-- Optimized pixel lookup
local string_byte = string.byte
local function get_alpha(buf, width, height, x, y)
    if x < 0 or x >= width or y < 0 or y >= height then return 0 end
    return string_byte(buf, (y * width + x) * 4 + 1 + 3)
end

-- Efficiently writes a quad into the buffer streams
local function write_face(p, t0, t1, n, idx,
                          v1, v2, v3, v4,
                          metadata,
                          norm,
                          u1, v1_uv, u2, v2_uv, u3, v3_uv, u4, v4_uv)
    local i = idx * 18 + 1
    local j = idx * 12 + 1
    local k = idx * 24 + 1
    local l = idx * 18 + 1

    -- Triangle 1 (CCW)
    p[i], p[i + 1], p[i + 2] = v1.x, v1.y, v1.z
    p[i + 3], p[i + 4], p[i + 5] = v2.x, v2.y, v2.z
    p[i + 6], p[i + 7], p[i + 8] = v3.x, v3.y, v3.z
    -- Triangle 2
    p[i + 9], p[i + 10], p[i + 11] = v1.x, v1.y, v1.z
    p[i + 12], p[i + 13], p[i + 14] = v3.x, v3.y, v3.z
    p[i + 15], p[i + 16], p[i + 17] = v4.x, v4.y, v4.z

    -- Texcoord0 (Normalized 0..1)
    t0[j], t0[j + 1] = u1, v1_uv
    t0[j + 2], t0[j + 3] = u2, v2_uv
    t0[j + 4], t0[j + 5] = u3, v3_uv
    t0[j + 6], t0[j + 7] = u1, v1_uv
    t0[j + 8], t0[j + 9] = u3, v3_uv
    t0[j + 10], t0[j + 11] = u4, v4_uv

    -- Texcoord1 (Atlas Metadata)
    local mu, mv, mw, mh = metadata.u, metadata.v, metadata.w, metadata.h
    for m = 0, 5 do
        local ki = k + m * 4
        t1[ki], t1[ki + 1], t1[ki + 2], t1[ki + 3] = mu, mv, mw, mh

        local li = l + m * 3
        n[li], n[li + 1], n[li + 2] = norm.x, norm.y, norm.z
    end

    return idx + 1
end

function build_voxel_mesh(self, item_index)
    local start_time = os.clock()
    local item = ITEMS[item_index]
    local meta = self.item_meta[item.id]
    if not meta then return end

    local img = meta.image
    local width, height = img.width, img.height
    local depth = self.depth
    local buf_data = img.buffer
    local ox, oy = -width * 0.5, -height * 0.5

    -- Maximum possible faces: 2 (front/back) + (width*height*4 sides)
    -- We'll use a dynamic allocation but with direct streaming
    local faces = {}
    local face_count = 0

    -- Helper for face data collection
    local function collect_face(v1, v2, v3, v4, m, norm, u1, v1_uv, u2, v2_uv, u3, v3_uv, u4, v4_uv)
        face_count = face_count + 1
        faces[face_count] = {
            v1 = v1,
            v2 = v2,
            v3 = v3,
            v4 = v4,
            m = m,
            norm = norm,
            u1 = u1,
            v1_uv = v1_uv,
            u2 = u2,
            v2_uv = v2_uv,
            u3 = u3,
            v3_uv = v3_uv,
            u4 = u4,
            v4_uv = v4_uv
        }
    end

    -- FRONT/BACK
    collect_face(vmath.vector3(ox, oy, depth), vmath.vector3(ox + width, oy, depth),
        vmath.vector3(ox + width, oy + height, depth), vmath.vector3(ox, oy + height, depth), meta,
        vmath.vector3(0, 0, 1), 0, 0, 1, 0, 1, 1, 0,
        1)
    collect_face(vmath.vector3(ox + width, oy, 0), vmath.vector3(ox, oy, 0), vmath.vector3(ox, oy + height, 0),
        vmath.vector3(ox + width, oy + height, 0), meta, vmath.vector3(0, 0, -1), 1, 0, 0, 0, 0, 1, 1, 1)

    -- SIDES
    for x = 0, width - 1 do
        for y = 0, height - 1 do
            if get_alpha(buf_data, width, height, x, y) > 128 then
                local pu, pv = (x + 0.5) / width, (height - 1 - y + 0.5) / height
                local pm = { u = meta.u + pu * meta.w, v = meta.v + pv * meta.h, w = 0.0001, h = 0.0001 }

                local h_y = height - 1 - y
                if get_alpha(buf_data, width, height, x - 1, y) < 128 then -- Left
                    collect_face(vmath.vector3(ox + x, oy + h_y, 0), vmath.vector3(ox + x, oy + h_y, depth),
                        vmath.vector3(ox + x, oy + h_y + 1, depth), vmath.vector3(ox + x, oy + h_y + 1, 0), pm,
                        vmath.vector3(-1, 0, 0), 0, 0, 0,
                        0, 0, 0, 0, 0)
                end
                if get_alpha(buf_data, width, height, x + 1, y) < 128 then -- Right
                    collect_face(vmath.vector3(ox + x + 1, oy + h_y, depth), vmath.vector3(ox + x + 1, oy + h_y, 0),
                        vmath.vector3(ox + x + 1, oy + h_y + 1, 0), vmath.vector3(ox + x + 1, oy + h_y + 1, depth), pm,
                        vmath.vector3(1, 0, 0), 0,
                        0, 0, 0, 0, 0, 0, 0)
                end
                if get_alpha(buf_data, width, height, x, y - 1) < 128 then -- Top
                    collect_face(vmath.vector3(ox + x, oy + h_y + 1, depth), vmath.vector3(ox + x + 1, oy + h_y + 1,
                            depth), vmath.vector3(ox + x + 1, oy + h_y + 1, 0), vmath.vector3(ox + x, oy + h_y + 1, 0),
                        pm, vmath.vector3(0, 1, 0), 0,
                        0, 0, 0, 0, 0, 0, 0)
                end
                if get_alpha(buf_data, width, height, x, y + 1) < 128 then -- Bottom
                    collect_face(vmath.vector3(ox + x, oy + h_y, 0), vmath.vector3(ox + x + 1, oy + h_y, 0),
                        vmath.vector3(ox + x + 1, oy + h_y, depth), vmath.vector3(ox + x, oy + h_y, depth), pm,
                        vmath.vector3(0, -1, 0), 0, 0, 0,
                        0, 0, 0, 0, 0)
                end
            end
        end
    end

    -- Create target buffer
    local buf = buffer.create(face_count * 6, {
        { name = H_POSITION,  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
        { name = H_TEXCOORD0, type = buffer.VALUE_TYPE_FLOAT32, count = 2 },
        { name = H_TEXCOORD1, type = buffer.VALUE_TYPE_FLOAT32, count = 4 },
        { name = H_NORMAL,    type = buffer.VALUE_TYPE_FLOAT32, count = 3 }
    })
    local ps = buffer.get_stream(buf, H_POSITION)
    local u0 = buffer.get_stream(buf, H_TEXCOORD0)
    local u1 = buffer.get_stream(buf, H_TEXCOORD1)
    local ns = buffer.get_stream(buf, H_NORMAL)

    -- Streaming write
    local current_idx = 0
    for f = 1, face_count do
        local face = faces[f]
        current_idx = write_face(ps, u0, u1, ns, current_idx, face.v1, face.v2, face.v3, face.v4, face.m, face.norm,
            face.u1, face
            .v1_uv, face.u2, face.v2_uv, face.u3, face.v3_uv, face.u4, face.v4_uv)
    end

    -- Mesh update
    if not self.held_mesh_url then
        local h_id = factory.create(self.mesh_prefab); self.held_mesh_url = msg.url(h_id); self.held_mesh_url.fragment =
            H_MESH
        go.set(self.held_mesh_url, H_TEXTURE0, hash(meta.texture))
        go.set_position(vmath.vector3(0.4, -0.08, -0.8), h_id)

        local qx = vmath.quat_rotation_x(math.rad(1))
        local qy = vmath.quat_rotation_y(math.rad(-65))

        local rot = qy * qx

        go.set_rotation(rot, h_id)


        go.set_scale(vmath.vector3(0.017, 0.017, 0.017), h_id)

        local pivot = self.sway_pivot
        if pivot.path == hash("") then pivot = go.get_id() end
        go.set_parent(h_id, pivot)

        local w_id = factory.create(self.mesh_prefab); self.world_mesh_url = msg.url(w_id); self.world_mesh_url.fragment =
            H_MESH
        go.set(self.world_mesh_url, H_TEXTURE0, hash(meta.texture))
        go.set_position(vmath.vector3(0, 10, 500), w_id); go.set_scale(vmath.vector3(0.05, 0.05, 0.05), w_id)

        self.item_buffers = {}
    end

    local path = "/item_" .. item_index .. ".bufferc"
    local res = self.item_buffers[item_index]
    if not res then
        res = resource.create_buffer(path, { buffer = buf })
        self.item_buffers[item_index] = res
    else
        resource.set_buffer(res, buf)
    end

    go.set(self.held_mesh_url, H_VERTICES, res); go.set(self.world_mesh_url, H_VERTICES, res)
    _G.item_mesh_build_time = (os.clock() - start_time) * 1000
end

function init(self)
    msg.post(".", H_ACQUIRE_INPUT_FOCUS)
    self.current_item = 1
    self.item_meta = {}

    local atlas_res = resource.get_atlas(self.game_atlas)
    local tex_info = resource.get_texture_info(atlas_res.texture)

    -- Pre-calculate and cache metadata for all items at startup
    for _, item in ipairs(ITEMS) do
        local img_data = sys.load_resource(item.path)
        if not img_data then img_data = sys.load_resource(string.sub(item.path, 2)) end

        if img_data then
            local img = image.load(img_data)
            local item_meta = { image = img, texture = atlas_res.texture, u = 0, v = 0, w = 1, h = 1 }

            for i, anim in ipairs(atlas_res.animations) do
                local anim_id = type(anim.id) == "string" and hash(anim.id) or anim.id
                if anim_id == item.id then
                    local geom = atlas_res.geometries[anim.frame_start]
                    local min_u, max_u, min_v, max_v = math.huge, -math.huge, math.huge, -math.huge
                    for j = 1, #geom.uvs, 2 do
                        local u, v = geom.uvs[j], geom.uvs[j + 1]
                        min_u = math.min(min_u, u); max_u = math.max(max_u, u)
                        min_v = math.min(min_v, v); max_v = math.max(max_v, v)
                    end
                    item_meta.u = min_u / tex_info.width
                    item_meta.v = (tex_info.height - max_v) / tex_info.height
                    item_meta.w = (max_u - min_u) / tex_info.width
                    item_meta.h = (max_v - min_v) / tex_info.height
                    break
                end
            end
            self.item_meta[item.id] = item_meta
        end
    end

    msg.post(".", H_BUILD_ITEM)
end

function on_message(self, message_id, message, sender)
    if message_id == H_BUILD_ITEM then build_voxel_mesh(self, self.current_item) end
end

function on_input(self, action_id, action)
    if action_id == H_SWITCH_ITEM and action.pressed then
        self.current_item = (self.current_item % #ITEMS) + 1
        build_voxel_mesh(self, self.current_item)
    end
end
