local function format_mem(kb)
    if kb > 1024 then
        return string.format("%d MB", math.floor(kb / 1024))
    else
        return string.format("%d KB", math.floor(kb))
    end
end

-- Helper to convert logical screen coordinates to world coordinates fixed to the camera
local function ScreenToWorld(x, y, d, cam_pos, cam_rot, width, height, aspect)
    local tan_half_fov = 0.41421356237309503 -- math.tan(math.rad(45)/2) cached

    -- Normalize screen coordinates to [-1, 1]
    local nx = (x / width - 0.5) * 2
    local ny = (y / height - 0.5) * 2

    -- Calculate position in camera space
    local dx = nx * d * tan_half_fov * aspect
    local dy = ny * d * tan_half_fov
    local dz = -d

    -- Rotate to world space and add camera position
    return cam_pos + vmath.rotate(cam_rot, vmath.vector3(dx, dy, dz))
end

local function DrawAxes(self, center_pos, axis_len)
    -- X-Axis (Red)
    msg.post("@render:", "draw_line", {
        start_point = center_pos,
        end_point = center_pos + vmath.vector3(axis_len, 0, 0),
        color = self.color_red
    })
    -- Y-Axis (Green)
    msg.post("@render:", "draw_line", {
        start_point = center_pos,
        end_point = center_pos + vmath.vector3(0, axis_len, 0),
        color = self.color_green
    })
    -- Z-Axis (Blue)
    msg.post("@render:", "draw_line", {
        start_point = center_pos,
        end_point = center_pos + vmath.vector3(0, 0, axis_len),
        color = self.color_blue
    })
end

function init(self)
    msg.post(".", "acquire_input_focus")
    self.mode = 0 -- 0: Off, 1: Text, 2: Text + Graph

    -- FPS Metrics (defold-metrics style)
    self.fps_samples = 60
    self.fps_frames = {}
    self.avg_fps = 0

    -- Graph & 1% Lows
    self.frame_times = {}
    self.max_graph_samples = 120

    self.current_time = socket.gettime()
    self.prev_time = self.current_time

    self.avg_fps = 0
    self.low_1_fps = 0

    -- Throttling for heavy operations only
    self.update_timer = 0
    self.update_interval = 0.5

    -- Pre-allocated objects
    self.color_green = vmath.vector4(0, 1, 0, 1)
    self.color_target = vmath.vector4(0, 1, 0, 0.2)
    self.color_red = vmath.vector4(1, 0, 0, 1)
    self.color_blue = vmath.vector4(0, 0.5, 1, 1)
    self.vec_offset = vmath.vector3(0, 0, 0)

    -- Logical size (fallback)
    self.logical_width = 960
    self.logical_height = 640

    -- Pre-allocated control text to avoid GC overhead
    self.controls = {
        "WASD: Move",
        "Shift: Sprint",
        "Space/Ctrl: Up/Down",
        "Left Click: Break",
        "Right Click: Place",
        "M: Toggle Metrics",
        "Q: Switch Item"
    }

    -- Cache window size for optimization
    self.width, self.height = window.get_size()

    -- Efficiently listen for window resize events instead of polling
    window.set_listener(function(self, event, data)
        if event == window.WINDOW_EVENT_RESIZED then
            self.width = data.width
            self.height = data.height
        end
    end)
end

function update(self, dt)
    -- 0. Always display controls (Persistent & Optimized)
    for i, line in ipairs(self.controls) do
        self.vec_offset.x = 20
        self.vec_offset.y = self.height - 20 - (i * 20)

        msg.post("@render:", "draw_debug_text", {
            text = line,
            position = self.vec_offset,
            color = self.color_green
        })
    end

    if self.mode == 0 then return end

    -- 1. Wall-Clock Time Measurements
    self.current_time = socket.gettime()
    local real_dt = self.current_time - self.prev_time
    self.prev_time = self.current_time

    -- 2. FPS Calculation (Strict defold-metrics logic)
    table.insert(self.fps_frames, self.current_time)
    if #self.fps_frames == self.fps_samples + 1 then
        table.remove(self.fps_frames, 1)
        local dt_total = self.fps_frames[#self.fps_frames] - self.fps_frames[1]
        if dt_total > 0 then
            self.avg_fps = (#self.fps_frames - 1) / dt_total
        end
    end

    -- 3. Delta Time for Graph & 1% Lows
    local dt_display = math.max(real_dt, 0.0001)

    -- 4. Sample Management for Graph & 1% Lows
    table.insert(self.frame_times, dt_display)
    if #self.frame_times > self.max_graph_samples then
        table.remove(self.frame_times, 1)
    end

    -- 5. Heavy Logic (Calculated every frame for immediate feedback)
    local samples = #self.frame_times
    if samples >= 20 then
        local sorted_times = {}
        for i, v in ipairs(self.frame_times) do sorted_times[i] = v end
        table.sort(sorted_times)
        local index = math.floor(samples * 0.99)
        self.low_1_fps = 1 / sorted_times[math.max(1, index)]
    end

    -- 6. Display Text (Real-time update as requested)
    local ram = collectgarbage("count")
    local faces = _G.stats_faces or 0
    local vertices = _G.stats_vertices or 0
    local build_time = _G.stats_mesh_build_time or 0

    local x_start = 20
    local y_start = 200

    local lines = {
        string.format("FPS: %.2f", self.avg_fps),
        string.format("1%% Low FPS: %.1f", self.low_1_fps),
        string.format("Faces: %d", faces),
        string.format("Vertices: %d", vertices),
        string.format("World Build: %.2f ms", build_time),
        string.format("Item Build: %.2f ms", _G.item_mesh_build_time or 0),
        string.format("RAM: %s", format_mem(ram))
    }

    for i, line in ipairs(lines) do
        self.vec_offset.x = x_start
        self.vec_offset.y = y_start - (i * 20)
        msg.post("@render:", "draw_debug_text", {
            text = line,
            position = self.vec_offset,
            color = self.color_green
        })
    end

    -- 7. Camera & Overlay Common Data (Optimized: cached shared values)
    local cam_pos = _G.cam_pos or vmath.vector3()
    local cam_rot = _G.cam_rot or vmath.quat()
    local aspect = self.width / self.height
    local d = 0.5 -- Distance in front of camera

    -- 8. Camera Stats (Top-Right)
    -- Convert quat to euler for readability
    local ce = vmath.vector3(math.deg(math.asin(2 * (cam_rot.w * cam_rot.x - cam_rot.y * cam_rot.z))),
        math.deg(math.atan2(2 * (cam_rot.w * cam_rot.y + cam_rot.z * cam_rot.x),
            1 - 2 * (cam_rot.x * cam_rot.x + cam_rot.y * cam_rot.y))),
        math.deg(math.atan2(2 * (cam_rot.w * cam_rot.z + cam_rot.x * cam_rot.y),
            1 - 2 * (cam_rot.y * cam_rot.y + cam_rot.z * cam_rot.z))))

    local cam_lines = {
        string.format("CAM POS: %.2f, %.2f, %.2f", cam_pos.x, cam_pos.y, cam_pos.z),
        string.format("CAM ROT: %.1f, %.1f, %.1f", ce.x, ce.y, ce.z)
    }

    for i, line in ipairs(cam_lines) do
        self.vec_offset.x = self.width - 260
        self.vec_offset.y = self.height - 20 - (i * 20)
        msg.post("@render:", "draw_debug_text", {
            text = line,
            position = self.vec_offset,
            color = self.color_green
        })
    end

    -- 9. Camera-Oriented Axes
    local center_x = self.width / 2
    local center_y = self.height / 2
    local center_pos = ScreenToWorld(center_x, center_y, d, cam_pos, cam_rot, self.width, self.height, aspect)
    DrawAxes(self, center_pos, 0.02)

    -- 10. Display Graph (Mode 2)
    if self.mode == 2 and #self.frame_times > 1 then
        -- Scale logical coordinates to actual screen coordinates
        local scale_x = self.width / self.logical_width
        local scale_y = self.height / self.logical_height

        local graph_width_scaled = 240 * scale_x
        local graph_height_scaled = 80 * scale_y
        local graph_x_scaled = x_start * scale_x
        local graph_y_scaled = (y_start + 10) * scale_y

        local max_graph_fps = 144
        local step_x = graph_width_scaled / (self.max_graph_samples - 1)

        -- Optimized Graph Loop
        local prev_h = math.min(1, (1 / (self.frame_times[1] or 0.016)) / max_graph_fps) * graph_height_scaled
        local prev_pos = ScreenToWorld(graph_x_scaled, graph_y_scaled + prev_h, d, cam_pos, cam_rot, self.width,
            self.height, aspect)

        for i = 2, #self.frame_times do
            local fps = 1 / self.frame_times[i]
            local h = math.min(1, fps / max_graph_fps) * graph_height_scaled
            local curr_x = graph_x_scaled + (i - 1) * step_x
            local curr_pos = ScreenToWorld(curr_x, graph_y_scaled + h, d, cam_pos, cam_rot, self.width,
                self.height, aspect)

            msg.post("@render:", "draw_line", {
                start_point = prev_pos,
                end_point = curr_pos,
                color = self.color_green
            })
            prev_pos = curr_pos
        end

        -- 60 FPS Target Line
        local h60 = (60 / max_graph_fps) * graph_height_scaled
        msg.post("@render:", "draw_line", {
            start_point = ScreenToWorld(graph_x_scaled, graph_y_scaled + h60, d, cam_pos, cam_rot, self.width,
                self.height, aspect),
            end_point = ScreenToWorld(graph_x_scaled + graph_width_scaled, graph_y_scaled + h60, d, cam_pos, cam_rot,
                self.width,
                self.height, aspect),
            color = self.color_target
        })
    end
end

function on_input(self, action_id, action)
    if action_id == hash("toggle_performance") and action.pressed then
        self.mode = (self.mode + 1) % 3
        local modes = { "Off", "Text", "Text + Graph" }
        print("Performance overlay mode: " .. modes[self.mode + 1])
        -- Notify camera to start/stop pushing data
        msg.post("camera", "set_performance_mode", { mode = self.mode })
    end
end
