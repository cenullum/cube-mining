-- hand_slot_manager.script
-- Purpose: Manages the player's held item/block slot, handles interactions like mining, placing blocks, throwing bombs, and aiming down sights.

local vmath = vmath
local msg = msg
local go = go
local factory = factory
local hash = hash
local math = math

local world = require "main.scripts.world"
local sm = require "main.scripts.sound_manager"
local items_data = require "main.scripts.items"
local block_data = require "main.scripts.block_data"

local H_ACQUIRE_INPUT_FOCUS = hash("acquire_input_focus")
local H_KEY_1 = hash("key_1")
local H_CLICK = hash("click")
local H_CLICK_RIGHT = hash("click_right")

-- Ordered list of available items and blocks for switching
local SWITCH_CYCLE = {}

go.property("bomb_factory", msg.url())
go.property("mouse_factory", msg.url())

-- Format item name for display (e.g., diamond_sword -> Diamond Sword)
local function format_item_name(name)
    if not name then return "Unknown" end
    -- Replace underscores with spaces
    local display_name = name:gsub("_", " ")
    -- Capitalize first letter of each word
    display_name = display_name:gsub("(%a)([%w]*)", function(first, rest)
        return first:upper() .. rest:lower()
    end)
    return display_name
end

local function update_global_item_name(self)
    local def = items_data.definitions[self.current_id]
    _G.held_item_name = def and format_item_name(def.name) or "Unknown"
end

function init(self)
    msg.post(".", H_ACQUIRE_INPUT_FOCUS)

    -- Dynamic initialization of SWITCH_CYCLE
    -- We want blocks first (IDs 1-6) then items (ID 10+)
    local keys = {}
    for k, _ in pairs(items_data.definitions) do
        if k ~= 0 then -- Skip air
            table.insert(keys, k)
        end
    end
    table.sort(keys)
    SWITCH_CYCLE = keys

    self.cycle_index = 1 -- Start with first item in the list
    self.current_id = SWITCH_CYCLE[self.cycle_index]
    local def = items_data.definitions[self.current_id]
    self.active_mode = def.type == "block" and "block" or "item"
    self.mining_target = nil
    self.mining_progress = 0
    self.ads_active = false

    -- Synchronize mesh with voxelizer on start
    msg.post("camera#voxelizer", "set_hand_state", { mode = self.active_mode, id = self.current_id })
    update_global_item_name(self)
end

function on_input(self, action_id, action)
    if not action_id then return end

    if action_id == H_KEY_1 and action.pressed then
        self.cycle_index = (self.cycle_index % #SWITCH_CYCLE) + 1
        self.current_id = SWITCH_CYCLE[self.cycle_index]
        local def = items_data.definitions[self.current_id]
        self.active_mode = def.type == "block" and "block" or "item"

        msg.post("camera#voxelizer", "set_hand_state", { mode = self.active_mode, id = self.current_id })
        update_global_item_name(self)
    elseif action_id == H_CLICK and action.pressed then
        local targeted = _G.targeted_cube
        if targeted then
            local target, gx, gy, gz, normal = targeted.target, targeted.gx, targeted.gy, targeted.gz, targeted.normal
            local damage = 1
            if self.active_mode == "item" then
                local item = items_data.definitions[self.current_id]
                if item.name:find("sword") then
                    msg.post("camera#voxelizer", "play_swing")
                end
                damage = item.mining_power or 1
            else
                damage = 1
            end

            local b_id = world.get_block(gx, gy, gz)
            if b_id ~= 0 and b_id ~= 2 then
                local b_def, base_def = block_data.get_block(b_id), items_data.definitions[b_id]
                if b_def and base_def then
                    local block_key = gx .. "_" .. gy .. "_" .. gz
                    if self.mining_target ~= block_key then
                        self.mining_target = block_key
                        self.mining_progress = 0
                    end
                    self.mining_progress = self.mining_progress + damage
                    local health = base_def.health or 1
                    if self.mining_progress >= health then
                        msg.post("root#main", "destroy_cube", { gx = gx, gy = gy, gz = gz })
                        self.mining_target = nil
                        -- Reset breaking effect
                        if _G.terrain_mesh_url then
                            go.set(_G.terrain_mesh_url, "break_info", vmath.vector4(0, 0, 8, 0))
                        end
                    else
                        -- Update breaking effect
                        if _G.terrain_mesh_url then
                            local frame = math.floor((self.mining_progress / health) * 8)
                            go.set(_G.terrain_mesh_url, "break_pos", vmath.vector4(gx, gy, gz, 0))
                            go.set(_G.terrain_mesh_url, "break_info", vmath.vector4(frame, 1, 8, 0))
                        end

                        local hit_pos = go.get_position()
                        sm.play(b_def.hit_sound or sm.HASHES.hit, 1.0, hit_pos)
                    end
                else
                    -- Reset breaking effect if we hit an unknown block or something went wrong
                    if self.mining_target then
                        self.mining_target = nil
                        if _G.terrain_mesh_url then
                            go.set(_G.terrain_mesh_url, "break_info", vmath.vector4(0, 0, 8, 0))
                        end
                    end
                end
            else
                -- Target is air or unbreakable, clear breaking effect
                if self.mining_target then
                    self.mining_target = nil
                    if _G.terrain_mesh_url then
                        go.set(_G.terrain_mesh_url, "break_info", vmath.vector4(0, 0, 8, 0))
                    end
                end
            end
        else
            -- No targeted cube, clear breaking effect
            if self.mining_target then
                self.mining_target = nil
                if _G.terrain_mesh_url then
                    go.set(_G.terrain_mesh_url, "break_info", vmath.vector4(0, 0, 8, 0))
                end
            end
        end
    elseif action_id == H_CLICK_RIGHT and action.pressed then
        local item = items_data.definitions[self.current_id]
        if item.is_placeable then
            local targeted = _G.targeted_cube
            if targeted then
                local gx, gy, gz, normal = targeted.gx, targeted.gy, targeted.gz, targeted.normal
                msg.post("root#main", "place_cube",
                    { gx = gx + normal.x, gy = gy + normal.y, gz = gz + normal.z, block_id = self.current_id })
            end
        elseif self.active_mode == "item" then
            if item.name == "bomb" then
                local cam_pos = go.get_world_position()
                local cam_rot = go.get_world_rotation()
                local cam_dir = vmath.rotate(cam_rot, vmath.vector3(0, 0, -1))
                local spawn_pos = cam_pos + cam_dir * 1.5
                local bomb_id = factory.create(self.bomb_factory, spawn_pos, vmath.quat())
                msg.post(bomb_id, "set_velocity", { velocity = cam_dir * 12.5 + vmath.vector3(0, 0.75, 0) })
                sm.play(sm.HASHES.swing)
            elseif item.name == "gun" then
                self.ads_active = not self.ads_active
                msg.post("camera#voxelizer", "set_ads", { active = self.ads_active })
                if self.ads_active then
                    msg.post("camera#voxelizer", "set_gun_vertical")
                else
                    msg.post("camera#voxelizer", "reset_gun_vertical")
                end
            end
        end
    end
end
