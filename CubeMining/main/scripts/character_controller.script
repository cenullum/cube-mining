-- character_controller.script
-- Purpose: Handles physical movement of the player character, including gravity, collision with world (physics module), walking, sprinting, jumping, and free-camera flying mode.

local physics = require "main.scripts.physics"

local vmath = vmath
local msg = msg
local go = go
local window = window
local factory = factory
local hash = hash
local math = math
local world = require "main.scripts.world"
local sm = require "main.scripts.sound_manager"

-- Pre-hashed strings for optimization
local H_CAMERA = hash("camera")
local H_ACQUIRE_INPUT_FOCUS = hash("acquire_input_focus")
local H_KEY_ESC = hash("key_esc")
local H_CLICK = hash("click")
local H_MOVE_FORWARD = hash("move_forward")
local H_MOVE_BACKWARD = hash("move_backward")
local H_MOVE_LEFT = hash("move_left")
local H_MOVE_RIGHT = hash("move_right")
local H_MOVE_UP = hash("move_up")
local H_MOVE_DOWN = hash("move_down")
local H_JUMP = hash("jump")
local H_SPRINT = hash("sprint")
local H_SWITCH_MODE = hash("switch_mode")
local H_SET_VIEW_PROJECTION = hash("set_view_projection")
local H_SET_VIEW = hash("set_view")
local H_DRAW_LINE = hash("draw_line")
local H_EULER = hash("euler")
local H_SET_PERFORMANCE_MODE = hash("set_performance_mode")
local H_SPAWN_MOUSE = hash("spawn_mouse")
local H_SPAWN_TORCH = hash("spawn_torch")
local H_SPAWN_FAST = hash("spawn_fast")
local H_TOGGLE_LIGHT_MODE = hash("toggle_light_mode")
local H_TOGGLE_AO = hash("toggle_ao")

go.property("speed", 5)
go.property("jump_force", 9.0) -- Tweaked for standard gravity
go.property("sensitivity", 0.15)
go.property("gravity", -25.0)
go.property("mouse_factory", msg.url())
go.property("bomb_factory", msg.url())


local STATE_FREE_CAM = 1
local STATE_WALK = 2

function init(self)
    msg.post(".", H_ACQUIRE_INPUT_FOCUS)

    -- Set starting position as requested
    go.set_position(vmath.vector3(1, 10, 500))

    self.state = STATE_WALK
    self.velocity = vmath.vector3(0, 0, 0)
    self.pitch = 0
    self.yaw = 0

    self.shake_intensity = 0
    self.shake_duration = 0

    -- Recoil state
    self.recoil_offset_pos = 0   -- Backward movement (local Z)
    self.recoil_offset_pitch = 0 -- Upward pitch

    -- Inputs
    self.input = vmath.vector3()
    self.sprinting = false
    self.jump_pressed = false
    self.fly_mode = true -- Start in fly mode (free cam)
    self.spawn_fast = false

    -- Character Physics params
    -- AABB size: 0.6 width, 1.5 height
    self.size = vmath.vector3(0.6, 1.5, 0.6)

    -- Eye Height (GO is at eyes, feet are below)
    self.eye_height = 1.25
    self.eye_offset = vmath.vector3(0, self.eye_height, 0)

    -- Mouse Lock
    window.set_mouse_lock(true)

    -- Initial camera setup
    local rot = go.get_rotation()
    local euler = go.get(".", H_EULER)
    self.yaw = euler.y
    self.pitch = euler.x
end

local function update_camera(self)
    -- Compute base rotation
    local current_yaw = self.yaw
    local current_pitch = self.pitch

    -- Apply screen shake
    local shake_duration = self.shake_duration
    if shake_duration > 0 then
        local intensity = self.shake_intensity
        local shake_x = (math.random() - 0.5) * 2.0 * intensity
        local shake_y = (math.random() - 0.5) * 2.0 * intensity
        current_yaw = current_yaw + shake_x
        current_pitch = current_pitch + shake_y
    end

    -- Apply recoil
    current_pitch = current_pitch + self.recoil_offset_pitch

    local rot = vmath.quat_rotation_y(math.rad(current_yaw)) * vmath.quat_rotation_x(math.rad(current_pitch))
    go.set_rotation(rot)

    -- GO is at eye level now, so no offset for camera view
    -- Recoil position offset (move back along local negative forward)
    local eye_pos = go.get_position()
    local forward = vmath.rotate(rot, vmath.vector3(0, 0, -1))
    eye_pos = eye_pos - forward * self.recoil_offset_pos

    -- Export camera state for performance_overlay
    _G.cam_pos = eye_pos
    _G.cam_rot = rot

    -- Continuous Mouse Spawning (Y Key)
    if self.spawn_fast then
        local cam_dir = vmath.rotate(rot, vmath.vector3(0, 0, -1))
        local spawn_pos = eye_pos + cam_dir * 2.0
        factory.create(self.mouse_factory, spawn_pos, vmath.quat())
        sm.play(sm.swing)
    end

    -- Camera View Matrix
    local view = vmath.matrix4_from_quat(rot)
    view = vmath.inv(view)
    local pos_inv = vmath.matrix4_translation(-eye_pos)
    view = view * pos_inv

    msg.post("@render:", H_SET_VIEW, { view = view })
end

function update(self, dt)
    -- Screen shake decay
    local shake_duration = self.shake_duration
    if shake_duration > 0 then
        shake_duration = shake_duration - dt
        if shake_duration <= 0 then
            shake_duration = 0
            self.shake_intensity = 0
        end
        self.shake_duration = shake_duration
    end

    -- Recoil decay
    local lerp_speed = 10
    self.recoil_offset_pos = vmath.lerp(math.min(dt * lerp_speed, 1.0), self.recoil_offset_pos, 0)
    self.recoil_offset_pitch = vmath.lerp(math.min(dt * lerp_speed, 1.0), self.recoil_offset_pitch, 0)

    -- Rotation Logic
    -- (Applied in update_camera directly from accumulated pitch/yaw)

    if self.state == STATE_FREE_CAM then
        -- Free Camera Logic (Spectator)
        local rot = go.get_rotation()
        local forward = vmath.rotate(rot, vmath.vector3(0, 0, -1))
        local right = vmath.rotate(rot, vmath.vector3(1, 0, 0))
        local up = vmath.vector3(0, 1, 0)

        local speed = self.speed * (self.sprinting and 3 or 1)

        local move_dir = forward * self.input.z + right * self.input.x + up * self.input.y
        if vmath.length_sqr(move_dir) > 0 then
            move_dir = vmath.normalize(move_dir)
        end

        local p = go.get_position()
        go.set_position(p + move_dir * speed * dt)

        self.velocity = vmath.vector3(0) -- Reset velocity for when we switch back
        _G.is_freecam = true
    elseif self.state == STATE_WALK then
        _G.is_freecam = false
        -- Character Controller Logic
        local rot_y = vmath.quat_rotation_y(math.rad(self.yaw))
        local forward = vmath.rotate(rot_y, vmath.vector3(0, 0, -1))
        local right = vmath.rotate(rot_y, vmath.vector3(1, 0, 0))

        -- Flatten forward/right to horizontal plane
        forward.y = 0
        right.y = 0
        if vmath.length_sqr(forward) > 0.001 then forward = vmath.normalize(forward) end
        if vmath.length_sqr(right) > 0.001 then right = vmath.normalize(right) end

        local wish_dir = forward * self.input.z + right * self.input.x
        if vmath.length_sqr(wish_dir) > 1 then wish_dir = vmath.normalize(wish_dir) end

        local speed = self.speed * (self.sprinting and 1.5 or 1)

        -- Apply horizontal movement
        local resistance = 10.0 -- Ground friction/damping
        local target_vel_x = wish_dir.x * speed
        local target_vel_z = wish_dir.z * speed

        -- Accelerate towards target velocity
        self.velocity.x = vmath.lerp(0.1, self.velocity.x, target_vel_x)
        self.velocity.z = vmath.lerp(0.1, self.velocity.z, target_vel_z)

        -- Gravity
        self.velocity.y = self.velocity.y + self.gravity * dt

        local eye_pos = go.get_position()
        local feet_pos = eye_pos - self.eye_offset

        -- Physics Step
        local new_feet_pos, new_vel, grounded = physics.move_and_slide(feet_pos, self.velocity, self.size, dt)

        self.velocity = new_vel

        -- Update EYES based on new FEET
        local new_eye_pos = new_feet_pos + self.eye_offset
        go.set_position(new_eye_pos)

        -- Jump
        if self.jump_pressed and grounded then
            self.velocity.y = self.jump_force
            self.jump_pressed = false -- Consume jump
        end

        -- Reset jump constraints if falling too fast
        if not grounded and self.velocity.y < -30 then self.velocity.y = -30 end

        -- Expose movement state for head bob (hand_slot_manager)
        local hvel = math.sqrt(self.velocity.x * self.velocity.x + self.velocity.z * self.velocity.z)
        _G.player_speed = hvel
        _G.player_sprinting = self.sprinting
    end

    -- Debug Drawing
    if _G.performance_mode == 2 then
        -- Calculate feet pos from GO pos (eyes)
        local pos = go.get_position() - self.eye_offset

        local half_size = self.size * 0.5
        -- Pivot at bottom-center of feet pos
        local min = pos + vmath.vector3(-half_size.x, 0, -half_size.z)
        local max = pos + vmath.vector3(half_size.x, self.size.y, half_size.z)
        local color = vmath.vector4(1, 0, 0, 1) -- Red

        -- Draw bottom rect
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, min.y, min.z),
                end_point = vmath.vector3(max.x, min.y, min.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, min.y, min.z),
                end_point = vmath.vector3(max.x, min.y, max.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, min.y, max.z),
                end_point = vmath.vector3(min.x, min.y, max.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, min.y, max.z),
                end_point = vmath.vector3(min.x, min.y, min.z),
                color =
                    color
            })

        -- Draw top rect
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, max.y, min.z),
                end_point = vmath.vector3(max.x, max.y, min.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, max.y, min.z),
                end_point = vmath.vector3(max.x, max.y, max.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, max.y, max.z),
                end_point = vmath.vector3(min.x, max.y, max.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, max.y, max.z),
                end_point = vmath.vector3(min.x, max.y, min.z),
                color =
                    color
            })

        -- Draw verticals
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, min.y, min.z),
                end_point = vmath.vector3(min.x, max.y, min.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, min.y, min.z),
                end_point = vmath.vector3(max.x, max.y, min.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(max.x, min.y, max.z),
                end_point = vmath.vector3(max.x, max.y, max.z),
                color =
                    color
            })
        msg.post("@render:", H_DRAW_LINE,
            {
                start_point = vmath.vector3(min.x, min.y, max.z),
                end_point = vmath.vector3(min.x, max.y, max.z),
                color =
                    color
            })
    end

    -- Update Hand Item Light
    local eye_pos = go.get_position()
    local grid_size = _G.grid_size or 16
    local offset = -grid_size / 2 + 0.5
    local px = math.floor(eye_pos.x - offset + 0.5)
    local py = math.floor(eye_pos.y - offset + 0.5)
    local pz = math.floor(eye_pos.z - 490 + 0.5)

    -- 1. Lighting calculation with caching
    if px ~= self.last_px or py ~= self.last_py or pz ~= self.last_pz then
        self.last_px, self.last_py, self.last_pz = px, py, pz

        local sun_l, source_l = world.get_lights(px, py, pz)
        local sun_f = sun_l / 15.0
        local source_f = (source_l / 15.0) * 1.5

        local ambient_light = vmath.vector4(
            math.max(0.02, sun_f + source_f * 1.0),
            math.max(0.02, sun_f + source_f * 0.9),
            math.max(0.02, sun_f + source_f * 0.6),
            1.0
        )
        _G.player_ambient_light = ambient_light

        -- Only update shader if ambient light actually changed
        if ambient_light ~= self.last_ambient_light then
            self.last_ambient_light = ambient_light
            if _G.voxelizer_mesh_url then
                pcall(function() go.set(_G.voxelizer_mesh_url, "tint", ambient_light) end)
            end
        end
    end

    -- Depth-based fog and clear color
    -- Surface is at grid top (grid_size-1 in grid coords).
    -- Player Y in grid coords: py (already calculated above)
    -- At surface (py >= grid_size-1): full sky blue
    -- 5 blocks below surface: full black
    local surface_y = grid_size - 1
    -- Calculate vertical position in grid units using the precise world Y
    local player_grid_y = (eye_pos.y - offset)
    local depth_below_surface = surface_y - player_grid_y
    local depth_factor = math.max(0, math.min(1, depth_below_surface / 5.0))

    -- Sky blue color
    local sky_r, sky_g, sky_b = 0.67, 0.79, 0.98
    local fog_r = sky_r * (1.0 - depth_factor)
    local fog_g = sky_g * (1.0 - depth_factor)
    local fog_b = sky_b * (1.0 - depth_factor)

    msg.post("@render:", "clear_color", { color = vmath.vector4(fog_r, fog_g, fog_b, 1.0) })

    -- Update fog color on entity and voxelizer materials
    local fog_vec = vmath.vector4(fog_r, fog_g, fog_b, 1.0)
    _G.fog_color = fog_vec
    if fog_vec ~= self.last_fog_vec then
        self.last_fog_vec = fog_vec
        if _G.voxelizer_mesh_url then
            pcall(function() go.set(_G.voxelizer_mesh_url, "fog_color", fog_vec) end)
        end
        if _G.terrain_mesh_url then
            pcall(function() go.set(_G.terrain_mesh_url, "fog_color", fog_vec) end)
        end
    end

    update_camera(self)
end

function on_input(self, action_id, action)
    if not action_id then
        if window.get_mouse_lock() then
            -- Mouse movement
            self.yaw = self.yaw - action.dx * self.sensitivity
            self.pitch = self.pitch + action.dy * self.sensitivity

            -- Clamp pitch
            if self.pitch > 89 then self.pitch = 89 end
            if self.pitch < -89 then self.pitch = -89 end
        end
        return
    end

    if action_id == H_KEY_ESC and action.released then
        window.set_mouse_lock(false)
    elseif action_id == H_CLICK and action.pressed and not window.get_mouse_lock() then
        window.set_mouse_lock(true)
        return
    end

    -- (Note: next_item, previous_item, click, click_right handling moved to hand_slot_manager.script)

    -- Movement Input
    if action_id == H_MOVE_FORWARD then
        if action.pressed then self.input.z = 1 elseif action.released then self.input.z = 0 end
    elseif action_id == H_MOVE_BACKWARD then
        if action.pressed then self.input.z = -1 elseif action.released then self.input.z = 0 end
    elseif action_id == H_MOVE_LEFT then
        if action.pressed then self.input.x = -1 elseif action.released then self.input.x = 0 end
    elseif action_id == H_MOVE_RIGHT then
        if action.pressed then self.input.x = 1 elseif action.released then self.input.x = 0 end
    elseif action_id == H_MOVE_UP and self.state == STATE_FREE_CAM then
        if action.pressed then self.input.y = 1 elseif action.released then self.input.y = 0 end
    elseif action_id == H_MOVE_DOWN and self.state == STATE_FREE_CAM then
        if action.pressed then self.input.y = -1 elseif action.released then self.input.y = 0 end
    elseif action_id == H_JUMP then
        if action.pressed then self.jump_pressed = true end
        if action.released then self.jump_pressed = false end
    elseif action_id == H_SPRINT then
        self.sprinting = not action.released
    elseif action_id == H_SWITCH_MODE and action.released then
        if self.state == STATE_FREE_CAM then
            self.state = STATE_WALK
            print("Switched to WALK mode")
        else
            self.state = STATE_FREE_CAM
            print("Switched to FREE CAM mode")
        end
    elseif action_id == H_SPAWN_MOUSE and action.released then
        -- Spawn one mouse forwards
        local cam_pos = go.get_world_position()
        local cam_rot = go.get_world_rotation()
        local cam_dir = vmath.rotate(cam_rot, vmath.vector3(0, 0, -1))
        local spawn_pos = cam_pos + cam_dir * 2.0
        factory.create(self.mouse_factory, spawn_pos, vmath.quat())
        sm.play(sm.swing)
    elseif action_id == H_TOGGLE_LIGHT_MODE and action.released then
        msg.post("/root#main", "toggle_light_mode")
        print("Light Mode Toggle Request Sent")
    elseif action_id == H_SPAWN_FAST then
        if action.pressed then
            self.spawn_fast = true
        elseif action.released then
            self.spawn_fast = false
        end
    elseif action_id == H_TOGGLE_AO and action.released then
        msg.post("/root#main", "toggle_ao")
        print("AO Toggle Request Sent")
    end
end

function on_message(self, message_id, message, sender)
    if message_id == hash("explosion") then
        local dist = vmath.length(go.get_world_position() - message.position)
        local max_dist = 12.0
        if dist < max_dist then
            -- Linear intensity falloff based on distance
            local intensity_factor = 1.0 - (dist / max_dist)

            self.shake_intensity = 5.0 * intensity_factor * message.force
            self.shake_duration = 0.35 * intensity_factor
        end
    elseif message_id == hash("apply_recoil") then
        local power = message.power or 1
        local is_ads = message.is_ads or false

        -- Reduce recoil if aiming down sights
        local ads_multiplier = is_ads and 0.4 or 1.0

        -- Add recoil offsets (stackable)
        self.recoil_offset_pos = self.recoil_offset_pos + (0.03 * power * ads_multiplier)
        self.recoil_offset_pitch = self.recoil_offset_pitch + (1.2 * power * ads_multiplier)

        -- Clamp recoil
        self.recoil_offset_pos = math.min(self.recoil_offset_pos, 0.5)
    end
end
