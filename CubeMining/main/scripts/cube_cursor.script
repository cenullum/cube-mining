local function get_targeted_cube(ray_start, ray_dir, max_dist)
    local step = 0.05 -- Adjusted for scale 1
    local dist = 0

    local grid_size = _G.grid_size or 5
    local offset = -grid_size / 2 + 0.5

    -- Grid offset from main.script
    local OFFSET_X = offset
    local OFFSET_Y = offset
    local OFFSET_Z = 490

    local last_p = ray_start

    while dist < max_dist do
        local p = ray_start + ray_dir * dist

        local gx = math.floor(p.x - OFFSET_X + 0.5)
        local gy = math.floor(p.y - OFFSET_Y + 0.5)
        local gz = math.floor(p.z - OFFSET_Z + 0.5)

        -- Bounds check
        if gx >= 0 and gx < grid_size and gy >= 0 and gy < grid_size and gz >= 0 and gz < grid_size then
            -- Check if the cube exists in the shared map
            local cube_idx = gx + gy * grid_size + gz * grid_size * grid_size
            local cube_exists = (_G.shared_cubemap == nil) or (_G.shared_cubemap[cube_idx] == true)

            if cube_exists then
                -- Check distance to ensure it's actually within a cube
                local cx, cy, cz = OFFSET_X + gx, OFFSET_Y + gy, OFFSET_Z + gz
                if math.abs(p.x - cx) <= 0.5 and math.abs(p.y - cy) <= 0.5 and math.abs(p.z - cz) <= 0.5 then
                    -- Calculate normal based on which side was entered
                    local normal = vmath.vector3(0, 0, 0)
                    local dx = p.x - cx
                    local dy = p.y - cy
                    local dz = p.z - cz

                    local abs_x = math.abs(dx)
                    local abs_y = math.abs(dy)
                    local abs_z = math.abs(dz)

                    if abs_x > abs_y and abs_x > abs_z then
                        normal.x = dx > 0 and 1 or -1
                    elseif abs_y > abs_z then
                        normal.y = dy > 0 and 1 or -1
                    else
                        normal.z = dz > 0 and 1 or -1
                    end

                    return vmath.vector3(cx, cy, cz), gx, gy, gz, normal
                end
            end
        end
        last_p = p
        dist = dist + step
    end
    return nil
end

function init(self)
    msg.post(".", "acquire_input_focus")
    -- Define unit cube vertices
    local v = {
        vmath.vector3(-0.5, -0.5, 0.5),  -- 1
        vmath.vector3(0.5, -0.5, 0.5),   -- 2
        vmath.vector3(0.5, 0.5, 0.5),    -- 3
        vmath.vector3(-0.5, 0.5, 0.5),   -- 4
        vmath.vector3(-0.5, -0.5, -0.5), -- 5
        vmath.vector3(0.5, -0.5, -0.5),  -- 6
        vmath.vector3(0.5, 0.5, -0.5),   -- 7
        vmath.vector3(-0.5, 0.5, -0.5)   -- 8
    }
    -- 12 triangles (6 faces)
    local indices = {
        1, 2, 3, 1, 3, 4,
        6, 5, 8, 6, 8, 7,
        4, 3, 7, 4, 7, 8,
        5, 6, 2, 5, 2, 1,
        2, 6, 7, 2, 7, 3,
        5, 1, 4, 5, 4, 8
    }

    local buf = buffer.create(#indices, {
        { name = hash("position"), type = buffer.VALUE_TYPE_FLOAT32, count = 3 }
    })
    local positions = buffer.get_stream(buf, "position")

    for i, idx in ipairs(indices) do
        local vert = v[idx]
        positions[(i - 1) * 3 + 1] = vert.x
        positions[(i - 1) * 3 + 2] = vert.y
        positions[(i - 1) * 3 + 3] = vert.z
    end

    local mesh_url = msg.url("#mesh")
    local buffer_resource = resource.create_buffer("/main/cursor.bufferc", { buffer = buf })
    go.set(mesh_url, "vertices", buffer_resource)

    self.visible = false
    msg.post("#mesh", "disable")

    self.target_grid = nil
    self.target_normal = nil
end

function update(self, dt)
    -- Get camera info from the "camera" GO
    local cam_pos = go.get_world_position("camera")
    local cam_rot = go.get_world_rotation("camera")
    local cam_dir = vmath.rotate(cam_rot, vmath.vector3(0, 0, -1))

    local target, gx, gy, gz, normal = get_targeted_cube(cam_pos, cam_dir, 100)
    if target then
        if not self.visible then
            msg.post("#mesh", "enable")
            self.visible = true
        end

        -- Position clearly on the face
        local face_pos = target + normal * 0.5
        go.set_position(face_pos)

        -- Scale: 0.1 on the normal axis, slightly larger on others to avoid z-fighting
        local s = vmath.vector3(1.01, 1.01, 1.01)
        if math.abs(normal.x) > 0.5 then
            s.x = 0.1
        elseif math.abs(normal.y) > 0.5 then
            s.y = 0.1
        else
            s.z = 0.1
        end
        go.set_scale(s)

        -- Rotation is implicit if we scale the right axis for an axis-aligned hit
        -- But let's follow the user's advice and ensure it looks right.
        -- For axis-aligned unit cubes, scaling the hit axis is enough.

        self.target_grid = { gx = gx, gy = gy, gz = gz }
        self.target_normal = normal
    else
        if self.visible then
            msg.post("#mesh", "disable")
            self.visible = false
        end
        self.target_grid = nil
        self.target_normal = nil
    end
end

function on_input(self, action_id, action)
    if action.pressed then
        if action_id == hash("click") then
            if self.visible and self.target_grid then
                msg.post("root#main", "destroy_cube", self.target_grid)
            end
        elseif action_id == hash("click_right") then
            if self.visible and self.target_grid and self.target_normal then
                local place_grid = {
                    gx = self.target_grid.gx + self.target_normal.x,
                    gy = self.target_grid.gy + self.target_normal.y,
                    gz = self.target_grid.gz + self.target_normal.z
                }
                msg.post("root#main", "place_cube", place_grid)
            end
        end
    end
end
