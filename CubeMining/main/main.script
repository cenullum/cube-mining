go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())

---@class game_script
---@field mesh_prefab url
---@field game_atlas resource
---@field num_indices number|nil
---@field grid_size number|nil
---@field buf buffer|nil
---@field positions bufferstream|nil
---@field mesh_url url|nil
---@field buffer_resource resource|nil
---@field update_counter number|nil
---@field time number

---@class mesh_object
---@field go_id hash
---@field mesh_url url
---@field vertices vector3[]|nil
---@field indices integer[]|nil
---@field positions bufferstream
---@field texcoord0 bufferstream
---@field normals bufferstream

local H_MESH = hash("mesh")
local PATCH_BUFFER = "/assets/models/patch_%s.bufferc"

---@param self game_script
---@return mesh_object
local function create_mesh(self)
	local object = {}
	object.go_id = factory.create(self.mesh_prefab)
	object.mesh_url = msg.url(object.go_id)
	object.mesh_url.fragment = H_MESH

	return object
end

---@param atlas_geometry table
---@param atlas_width number
---@param atlas_height number
local function atlas_to_mesh_uv(atlas_geometry, atlas_width, atlas_height)
	-- Calculate UV bounds from all vertices
	local min_u = math.huge
	local max_u = -math.huge
	local min_v = math.huge
	local max_v = -math.huge

	for i = 1, #atlas_geometry.uvs, 2 do
		min_u = math.min(min_u, atlas_geometry.uvs[i])
		max_u = math.max(max_u, atlas_geometry.uvs[i])
		min_v = math.min(min_v, atlas_geometry.uvs[i + 1])
		max_v = math.max(max_v, atlas_geometry.uvs[i + 1])
	end

	min_u     = min_u / atlas_width
	max_u     = max_u / atlas_width
	min_v     = min_v / atlas_height
	max_v     = max_v / atlas_height

	local uvs = {
		{ u = min_u, v = 1 - min_v },
		{ u = min_u, v = 1 - max_v },
		{ u = max_u, v = 1 - max_v },
		{ u = max_u, v = 1 - min_v }
	}

	return uvs
end
---@param atlas_geometry table
---@param atlas_width number
---@param atlas_height number
local function rotated_atlas_to_mesh_uv(atlas_geometry, atlas_width, atlas_height)
	local image_width = atlas_geometry.width
	local image_height = atlas_geometry.height

	-- Calculate UV bounds from all vertices
	local min_u = math.huge
	local max_u = -math.huge
	local min_v = math.huge
	local max_v = -math.huge

	for i = 1, #atlas_geometry.uvs, 2 do
		min_u = math.min(min_u, atlas_geometry.uvs[i])
		max_u = math.max(max_u, atlas_geometry.uvs[i])
		min_v = math.min(min_v, atlas_geometry.uvs[i + 1])
		max_v = math.max(max_v, atlas_geometry.uvs[i + 1])
	end

	-- Detect rotation by comparing UV layout with geometry dimensions
	local is_rotated = atlas_geometry.rotated -- Available in Defold 1.11.0
	if is_rotated == nil then
		local uv_width = math.abs(max_u - min_u)
		local uv_height = math.abs(max_v - min_v)
		is_rotated = (uv_width ~= image_width) or (uv_height ~= image_height)
	end

	min_u = min_u / atlas_width
	max_u = max_u / atlas_width
	min_v = min_v / atlas_height
	max_v = max_v / atlas_height

	local uvs
	if is_rotated then
		uvs = {
			{ u = max_u, v = 1 - min_v },
			{ u = min_u, v = 1 - min_v },
			{ u = min_u, v = 1 - max_v },
			{ u = max_u, v = 1 - max_v },
		}
	else
		uvs = {
			{ u = min_u, v = 1 - min_v },
			{ u = min_u, v = 1 - max_v },
			{ u = max_u, v = 1 - max_v },
			{ u = max_u, v = 1 - min_v }
		}
	end

	return uvs
end

--- Show a 3D cube generated at runtime
---@param self game_script
local function example_7(self)
	local mesh_go = create_mesh(self)

	-- Define 8 vertices of a unit cube
	local v = {
		vmath.vector3(-0.5, -0.5, 0.5), -- 1
		vmath.vector3(0.5, -0.5, 0.5), -- 2
		vmath.vector3(0.5, 0.5, 0.5), -- 3
		vmath.vector3(-0.5, 0.5, 0.5), -- 4
		vmath.vector3(-0.5, -0.5, -0.5), -- 5
		vmath.vector3(0.5, -0.5, -0.5), -- 6
		vmath.vector3(0.5, 0.5, -0.5), -- 7
		vmath.vector3(-0.5, 0.5, -0.5) -- 8
	}


	-- Define indices for 12 triangles (6 faces)
	local indices = {
		-- Front
		1, 2, 3, 1, 3, 4,
		-- Back
		6, 5, 8, 6, 8, 7,
		-- Top
		4, 3, 7, 4, 7, 8,
		-- Bottom
		5, 6, 2, 5, 2, 1,
		-- Right
		2, 6, 7, 2, 7, 3,
		-- Left
		5, 1, 4, 5, 4, 8
	}

	-- Create a buffer for a 5x5x5 grid (125 cubes, 36 vertices per cube)
	local grid_size = 5
	local num_cubes = grid_size * grid_size * grid_size
	local buf = buffer.create(#indices * num_cubes, {
		{ name = hash("position"),  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		{ name = hash("texcoord0"), type = buffer.VALUE_TYPE_FLOAT32, count = 2 }
	})

	local positions = buffer.get_stream(buf, "position")
	local texcoord0 = buffer.get_stream(buf, "texcoord0")

	local atlas = resource.get_atlas(self.game_atlas)
	go.set(mesh_go.mesh_url, "texture0", hash(atlas.texture))

	local texture_info = resource.get_texture_info(atlas.texture)

	local top_id, side_id
	for index, animation in ipairs(atlas.animations) do
		if animation.id == hash("top") or animation.id == "top" then
			top_id = index
		elseif animation.id == hash("side") or animation.id == "side" then
			side_id = index
		end
	end

	local top_uvs = rotated_atlas_to_mesh_uv(atlas.geometries[top_id], texture_info.width, texture_info.height)
	local side_uvs = rotated_atlas_to_mesh_uv(atlas.geometries[side_id], texture_info.width, texture_info.height)

	local uv_point_indices = { 2, 3, 4, 2, 4, 1 }

	local cube_idx = 0
	for z = 0, grid_size - 1 do
		for y = 0, grid_size - 1 do
			for x = 0, grid_size - 1 do
				local base_entry = cube_idx * #indices

				for i, idx in ipairs(indices) do
					local vert = v[idx]
					local entry = base_entry + i
					positions[(entry - 1) * 3 + 1] = vert.x + x
					positions[(entry - 1) * 3 + 2] = vert.y + y
					positions[(entry - 1) * 3 + 3] = vert.z + z

					local current_uvs = side_uvs
					if i > 12 and i <= 24 then
						current_uvs = top_uvs
					end

					local local_i = ((i - 1) % 6) + 1
					local uv_point_idx = uv_point_indices[local_i]
					texcoord0[(entry - 1) * 2 + 1] = current_uvs[uv_point_idx].u
					texcoord0[(entry - 1) * 2 + 2] = current_uvs[uv_point_idx].v
				end
				cube_idx = cube_idx + 1
			end
		end
	end

	self.num_indices = #indices
	self.grid_size = grid_size
	self.buf = buf
	self.positions = positions
	self.mesh_url = mesh_go.mesh_url

	-- Initialize global cubemap
	_G.shared_cubemap = {}
	for i = 0, num_cubes - 1 do
		_G.shared_cubemap[i] = true
	end

	self.buffer_resource = resource.create_buffer(string.format(PATCH_BUFFER, 7), { buffer = buf })
	go.set(mesh_go.mesh_url, "vertices", self.buffer_resource)

	-- Position the grid near the camera (camera is at z=500 by default)
	-- Grid spans roughly [0, 5] in each axis if we don't offset.
	-- Let's center it roughly in front of the camera.
	go.set_position(vmath.vector3(-2.5, -2.5, 490), mesh_go.go_id)
	-- Scale is now 1
	go.set_scale(vmath.vector3(1, 1, 1), mesh_go.go_id)
end

---@param self game_script
function init(self)
	-- msg.post("@render:", "use_fixed_fit_projection", { near = -1000, far = 1000 })

	example_7(self)

	self.time = 0
end

---@param self game_script
function on_message(self, message_id, message, sender)
	if message_id == hash("destroy_cube") then
		local gx, gy, gz = message.gx, message.gy, message.gz
		if gx and gy and gz and self.grid_size then
			local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
			local base_entry = cube_idx * self.num_indices

			-- Mark as destroyed in shared map
			if _G.shared_cubemap then
				_G.shared_cubemap[cube_idx] = false
			end

			for i = 1, self.num_indices do
				local entry = base_entry + i
				self.positions[(entry - 1) * 3 + 1] = 0
				self.positions[(entry - 1) * 3 + 2] = 0
				self.positions[(entry - 1) * 3 + 3] = 0
			end

			-- Update the existing resource correctly
			-- If the direct set doesn't work, we use resource.set_buffer or create a new one
			local success = pcall(function()
				resource.set_buffer(self.buffer_resource, self.buf)
			end)

			if not success then
				-- Fallback for older versions or if set_resource failed: create a new one with unique path
				self.update_counter = (self.update_counter or 0) + 1
				local unique_path = string.format("/assets/models/patch_7_%d.bufferc", self.update_counter)
				self.buffer_resource = resource.create_buffer(unique_path, { buffer = self.buf })
			end

			-- Re-set to be sure
			go.set(self.mesh_url, "vertices", self.buffer_resource)
		end
	end
end

function final(self)
	resource.release(string.format(PATCH_BUFFER, 7))
end
