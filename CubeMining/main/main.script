go.property("mesh_prefab", msg.url())
go.property("game_atlas", resource.atlas())
go.property("grid_size", 16)

---@class game_script
---@field mesh_prefab url
---@field game_atlas resource
---@field num_indices number|nil
---@field grid_size number|nil
---@field buf buffer|nil
---@field positions bufferstream|nil
---@field texcoord0 bufferstream|nil
---@field mesh_url url|nil
---@field buffer_resource resource|nil
---@field update_counter number|nil
---@field time number
---@field world number[][][]|nil
---@field v_template vector3[]|nil
---@field indices_template integer[]|nil

---@class mesh_object
---@field go_id hash
---@field mesh_url url
---@field vertices vector3[]|nil
---@field indices integer[]|nil
---@field positions bufferstream
---@field texcoord0 bufferstream
---@field normals bufferstream

local H_MESH = hash("mesh")
local PATCH_BUFFER = "/assets/models/patch_%s.bufferc"

_G.stats_faces = 0
_G.stats_vertices = 0
_G.stats_mesh_build_time = 0

---@param self game_script
---@return mesh_object


local function create_mesh(self)
	local object = {}
	object.go_id = factory.create(self.mesh_prefab)
	object.mesh_url = msg.url(object.go_id)
	object.mesh_url.fragment = H_MESH

	return object
end

---@param atlas_geometry table
---@param atlas_width number
---@param atlas_height number
local function atlas_to_mesh_uv(atlas_geometry, atlas_width, atlas_height)
	-- Calculate UV bounds from all vertices
	local min_u = math.huge
	local max_u = -math.huge
	local min_v = math.huge
	local max_v = -math.huge

	for i = 1, #atlas_geometry.uvs, 2 do
		min_u = math.min(min_u, atlas_geometry.uvs[i])
		max_u = math.max(max_u, atlas_geometry.uvs[i])
		min_v = math.min(min_v, atlas_geometry.uvs[i + 1])
		max_v = math.max(max_v, atlas_geometry.uvs[i + 1])
	end

	min_u     = min_u / atlas_width
	max_u     = max_u / atlas_width
	min_v     = min_v / atlas_height
	max_v     = max_v / atlas_height

	local uvs = {
		{ u = min_u, v = 1 - min_v },
		{ u = min_u, v = 1 - max_v },
		{ u = max_u, v = 1 - max_v },
		{ u = max_u, v = 1 - min_v }
	}

	return uvs
end
---@param atlas_geometry table
---@param atlas_width number
---@param atlas_height number
local function rotated_atlas_to_mesh_uv(atlas_geometry, atlas_width, atlas_height)
	local image_width = atlas_geometry.width
	local image_height = atlas_geometry.height

	-- Calculate UV bounds from all vertices
	local min_u = math.huge
	local max_u = -math.huge
	local min_v = math.huge
	local max_v = -math.huge

	for i = 1, #atlas_geometry.uvs, 2 do
		min_u = math.min(min_u, atlas_geometry.uvs[i])
		max_u = math.max(max_u, atlas_geometry.uvs[i])
		min_v = math.min(min_v, atlas_geometry.uvs[i + 1])
		max_v = math.max(max_v, atlas_geometry.uvs[i + 1])
	end

	-- Detect rotation by comparing UV layout with geometry dimensions
	local is_rotated = atlas_geometry.rotated -- Available in Defold 1.11.0
	if is_rotated == nil then
		local uv_width = math.abs(max_u - min_u)
		local uv_height = math.abs(max_v - min_v)
		is_rotated = (uv_width ~= image_width) or (uv_height ~= image_height)
	end

	min_u = min_u / atlas_width
	max_u = max_u / atlas_width
	min_v = min_v / atlas_height
	max_v = max_v / atlas_height

	local uvs
	if is_rotated then
		uvs = {
			{ u = max_u, v = 1 - min_v },
			{ u = min_u, v = 1 - min_v },
			{ u = min_u, v = 1 - max_v },
			{ u = max_u, v = 1 - max_v },
		}
	else
		uvs = {
			{ u = min_u, v = 1 - min_v },
			{ u = min_u, v = 1 - max_v },
			{ u = max_u, v = 1 - max_v },
			{ u = max_u, v = 1 - min_v }
		}
	end

	return uvs
end

---@param self game_script
local function get_block(self, x, y, z)
	if x < 0 or x >= (self.grid_size or 0) or y < 0 or y >= (self.grid_size or 0) or z < 0 or z >= (self.grid_size or 0) then
		return 0 -- Air out of bounds
	end
	return self.world[x][y][z]
end

---@param self game_script
local function update_mesh(self)
	local start_time = os.clock()
	local v = self.v_template
	local indices = self.indices_template
	local positions = self.positions
	local texcoord0 = self.texcoord0

	-- Count total cubes and calculate baseline faces
	local total_cubes = 0
	for z = 0, self.grid_size - 1 do
		for y = 0, self.grid_size - 1 do
			for x = 0, self.grid_size - 1 do
				if self.world[x][y][z] == 1 then
					total_cubes = total_cubes + 1
				end
			end
		end
	end

	local baseline_faces = total_cubes * 6
	local visible_faces = 0
	local cube_idx = 0

	for z = 0, self.grid_size - 1 do
		for y = 0, self.grid_size - 1 do
			for x = 0, self.grid_size - 1 do
				local is_solid = self.world[x][y][z] == 1
				local base_entry = cube_idx * #indices

				-- Check 6 directions for culling
				-- Front, Back, Top, Bottom, Right, Left
				local neighbor_offsets = {
					{ dx = 0,  dy = 0,  dz = 1 }, -- Front
					{ dx = 0,  dy = 0,  dz = -1 }, -- Back
					{ dx = 0,  dy = 1,  dz = 0 }, -- Top
					{ dx = 0,  dy = -1, dz = 0 }, -- Bottom
					{ dx = 1,  dy = 0,  dz = 0 }, -- Right
					{ dx = -1, dy = 0,  dz = 0 } -- Left
				}

				for f = 1, 6 do
					local face_visible = false
					if is_solid then
						local nx, ny, nz = x + neighbor_offsets[f].dx, y + neighbor_offsets[f].dy,
							z + neighbor_offsets[f].dz
						-- If neighbor is air, the face is visible
						if get_block(self, nx, ny, nz) == 0 then
							face_visible = true
							visible_faces = visible_faces + 1
						end
					end

					local face_indices_start = (f - 1) * 6 + 1
					for i = 0, 5 do
						local idx_in_face = face_indices_start + i
						local vert_idx = indices[idx_in_face]
						local entry = base_entry + idx_in_face

						if face_visible then
							local vert = v[vert_idx]
							positions[(entry - 1) * 3 + 1] = vert.x + x
							positions[(entry - 1) * 3 + 2] = vert.y + y
							positions[(entry - 1) * 3 + 3] = vert.z + z
						else
							-- Hide face by zeroing out vertices
							positions[(entry - 1) * 3 + 1] = 0
							positions[(entry - 1) * 3 + 2] = 0
							positions[(entry - 1) * 3 + 3] = 0
						end
					end
				end
				cube_idx = cube_idx + 1
			end
		end
	end

	print(string.format("=== Face Statistics ==="))
	print(string.format("Total cubes: %d", total_cubes))
	print(string.format("Baseline faces (no optimization): %d", baseline_faces))
	print(string.format("Culled faces (hidden removed): %d", visible_faces))
	print(string.format("Greedy mesh faces: %d (not yet implemented)", visible_faces))

	_G.stats_faces = visible_faces
	_G.stats_vertices = visible_faces * 6

	-- Update the existing resource correctly
	local success = pcall(function()
		resource.set_buffer(self.buffer_resource, self.buf)
	end)

	if not success then
		self.update_counter = (self.update_counter or 0) + 1
		local unique_path = string.format("/assets/models/patch_7_%d.bufferc", self.update_counter)
		self.buffer_resource = resource.create_buffer(unique_path, { buffer = self.buf })
	end

	go.set(self.mesh_url, "vertices", self.buffer_resource)
	_G.stats_mesh_build_time = (os.clock() - start_time) * 1000
end




--- Show a 3D cube generated at runtime
---@param self game_script
local function example_7(self)
	local mesh_go = create_mesh(self)

	-- Define 8 vertices of a unit cube
	self.v_template = {
		vmath.vector3(-0.5, -0.5, 0.5), -- 1
		vmath.vector3(0.5, -0.5, 0.5), -- 2
		vmath.vector3(0.5, 0.5, 0.5), -- 3
		vmath.vector3(-0.5, 0.5, 0.5), -- 4
		vmath.vector3(-0.5, -0.5, -0.5), -- 5
		vmath.vector3(0.5, -0.5, -0.5), -- 6
		vmath.vector3(0.5, 0.5, -0.5), -- 7
		vmath.vector3(-0.5, 0.5, -0.5) -- 8
	}

	-- Define indices for 12 triangles (6 faces)
	self.indices_template = {
		-- Front (+Z)
		1, 2, 3, 1, 3, 4,
		-- Back (-Z)
		6, 5, 8, 6, 8, 7,
		-- Top (+Y)
		4, 3, 7, 4, 7, 8,
		-- Bottom (-Y)
		5, 6, 2, 5, 2, 1,
		-- Right (+X)
		2, 6, 7, 2, 7, 3,
		-- Left (-X)
		5, 1, 4, 5, 4, 8
	}

	-- Create a buffer for the grid
	local grid_size = self.grid_size
	_G.grid_size = grid_size
	local num_cubes = grid_size * grid_size * grid_size
	local buf = buffer.create(#self.indices_template * num_cubes, {
		{ name = hash("position"),  type = buffer.VALUE_TYPE_FLOAT32, count = 3 },
		{ name = hash("texcoord0"), type = buffer.VALUE_TYPE_FLOAT32, count = 2 }
	})

	self.buf = buf
	self.positions = buffer.get_stream(buf, "position")
	self.texcoord0 = buffer.get_stream(buf, "texcoord0")

	local atlas = resource.get_atlas(self.game_atlas)
	go.set(mesh_go.mesh_url, "texture0", hash(atlas.texture))

	local texture_info = resource.get_texture_info(atlas.texture)

	local top_id, side_id
	for index, animation in ipairs(atlas.animations) do
		if animation.id == hash("top") or animation.id == "top" then
			top_id = index
		elseif animation.id == hash("side") or animation.id == "side" then
			side_id = index
		end
	end

	local top_uvs = rotated_atlas_to_mesh_uv(atlas.geometries[top_id], texture_info.width, texture_info.height)
	local side_uvs = rotated_atlas_to_mesh_uv(atlas.geometries[side_id], texture_info.width, texture_info.height)

	local uv_point_indices = { 2, 3, 4, 2, 4, 1 }

	-- Initialize static UVs once
	local cube_idx = 0
	for z = 0, grid_size - 1 do
		for y = 0, grid_size - 1 do
			for x = 0, grid_size - 1 do
				local base_entry = cube_idx * #self.indices_template
				for i = 1, #self.indices_template do
					local current_uvs = side_uvs
					if i > 12 and i <= 24 then
						current_uvs = top_uvs
					end
					local local_i = ((i - 1) % 6) + 1
					local uv_point_idx = uv_point_indices[local_i]
					local entry = base_entry + i
					self.texcoord0[(entry - 1) * 2 + 1] = current_uvs[uv_point_idx].u
					self.texcoord0[(entry - 1) * 2 + 2] = current_uvs[uv_point_idx].v
				end
				cube_idx = cube_idx + 1
			end
		end
	end

	-- Initialize world state
	self.world = {}
	_G.shared_cubemap = {}
	for cx = 0, grid_size - 1 do
		self.world[cx] = {}
		for cy = 0, grid_size - 1 do
			self.world[cx][cy] = {}
			for cz = 0, grid_size - 1 do
				self.world[cx][cy][cz] = 1 -- 1 for solid, 0 for air
				local cube_idx = cx + cy * grid_size + cz * grid_size * grid_size
				_G.shared_cubemap[cube_idx] = true
			end
		end
	end

	self.num_indices = #self.indices_template
	self.mesh_url = mesh_go.mesh_url
	self.buffer_resource = resource.create_buffer(string.format(PATCH_BUFFER, 7), { buffer = buf })

	-- Initial mesh update (culls internal faces)
	update_mesh(self)

	-- Position the grid (centered)
	local offset = -self.grid_size / 2 + 0.5
	go.set_position(vmath.vector3(offset, offset, 490), mesh_go.go_id)
	go.set_scale(vmath.vector3(1, 1, 1), mesh_go.go_id)
end

---@param self game_script
function init(self)
	-- msg.post("@render:", "use_fixed_fit_projection", { near = -1000, far = 1000 })

	example_7(self)

	self.time = 0
end

function update(self, dt)
end

---@param self game_script
function on_message(self, message_id, message, sender)
	if message_id == hash("destroy_cube") then
		local gx, gy, gz = message.gx, message.gy, message.gz
		if gx and gy and gz and self.grid_size then
			-- Update world state
			if self.world[gx] and self.world[gx][gy] and self.world[gx][gy][gz] then
				self.world[gx][gy][gz] = 0 -- Air

				-- Sync shared map for cursor
				local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
				if _G.shared_cubemap then
					_G.shared_cubemap[cube_idx] = false
				end

				update_mesh(self)
			end
		end
	elseif message_id == hash("place_cube") then
		local gx, gy, gz = message.gx, message.gy, message.gz
		if gx and gy and gz and self.grid_size then
			-- Bounds check
			if gx >= 0 and gx < self.grid_size and gy >= 0 and gy < self.grid_size and gz >= 0 and gz < self.grid_size then
				-- Update world state
				if self.world[gx] and self.world[gx][gy] and self.world[gx][gy][gz] == 0 then
					self.world[gx][gy][gz] = 1 -- Solid

					-- Sync shared map for cursor
					local cube_idx = gx + gy * self.grid_size + gz * self.grid_size * self.grid_size
					if _G.shared_cubemap then
						_G.shared_cubemap[cube_idx] = true
					end

					update_mesh(self)
				end
			end
		end
	end
end

function final(self)
	resource.release(string.format(PATCH_BUFFER, 7))
end
