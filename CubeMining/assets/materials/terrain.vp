#version 140

in highp vec4 position;     // Local vertex position (x, y, z)
in mediump vec2 texcoord0;  // Tiling coordinates
in mediump vec4 texcoord1;  // Atlas metadata
in mediump vec3 normal;      // Normal vector
in mediump vec4 color;       // Corner AO (Manual interpolation data)
in mediump vec4 color1;      // Corner Torch Light
in mediump vec4 color2;      // Corner Sun Light
in mediump vec2 texcoord2;   // Local UV [0..1] for bilinear interpolation

// --- Outputs ---
out mediump vec2 var_texcoord0;     // Passed to fragment shader
out mediump vec4 var_atlas_metadata; // Passed to fragment shader
out mediump float var_light;        // Directional Lighting factor
out mediump vec4 var_corner_ao;     // Pass all 4 corners
out mediump vec4 var_corner_torch;  // Pass all 4 corners
out mediump vec4 var_corner_sun;    // Pass all 4 corners
out mediump vec2 var_local_uv;      // Local quad UV [0..1]
out mediump vec3 var_view_pos;      // Position in view space
out mediump vec3 var_pos;           // Position for block breaking
out mediump vec3 var_normal;        // Normal for block breaking

// --- Uniforms ---
uniform vs_uniforms
{
    uniform mediump mat4 mtx_worldview;
    uniform mediump mat4 mtx_proj;
    uniform mediump mat4 mtx_normal;
    uniform mediump vec4 light;
};

void main()
{
    // Standard position transformation
    vec4 p = mtx_worldview * position;
    
    // Calculate diffuse lighting in world space
    // Terrain GO is axis-aligned and not rotated, so local normal = world normal
    vec3 n = normalize(normal);
    float diff = max(dot(n, normalize(light.xyz)), 0.0);
    var_light = diff + light.w; // Add ambient factor
    
    // Pass attributes to fragment shader
    var_texcoord0 = texcoord0;
    var_atlas_metadata = texcoord1;
    var_corner_ao = color;
    var_corner_torch = color1;
    var_corner_sun = color2;
    var_local_uv = texcoord2;
    
    // Pass view-space position for fog
    var_view_pos = p.xyz;
    var_pos = position.xyz;
    var_normal = normal;

    // Final clip space position
    gl_Position = mtx_proj * p;
}
